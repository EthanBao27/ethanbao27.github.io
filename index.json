
[{"content":"","date":"23 July 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"23 July 2025","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"Git 是什么?\nGit 是一个分布式版本控制系统（Version Control System），它的核心作用是追踪和管理文件和代码的变化，帮助个人或团队高效协作开发。简单来说，Git 就像一个“时间机器”，能记录你项目中每一次修改的历史，并能随时回退到任意版本。 flowchart LR %% 定义统一样式 classDef defaultStyle fill:#fefefe,stroke:#4B83A1,stroke-width:2px,rx:6,ry:6,color:#333; %% 节点 A[工作区] --\u003e|git add| B[暂存区] B --\u003e|git commit| C[本地仓库] C --\u003e|git push| D[远程仓库] %% 应用样式 class A,B,C,D defaultStyle; 基础 # Git Commit\n-m (message) 提交当前 HEAD 分支的更改 Git Branch (name) 创建一个分支\n-f (name) 创建分支并切换到该分支 Git Merge (branch_name)\n基于当前 HEAD 分支，将 branch_name 分支合并到目前分支，创建一个新的提交记录（本质是合并两个 parent 结点） Git Rebase(变基) (branch_name)\n类似于 merge，但是区别是不创建新的提交记录，而是将非公共部分的所有部分转移到 branch_name 下方 高级 # 分离 HEAD # Git Checkout [name] 将 HEAD 指针移动到对应提交记录 相对引用 # ^ (name)^ 可以选择当前提交的 parent 结点，即上一次提交\n~ (name)~(数字) 可以选择当前提交的第 n 个 parent 结点\n撤销变更 # Git Reset (name) 可以把分支回退对应的提交记录，相当于“改写历史“，只适用于本地仓库 Git Revert (name) 新建一个提交记录，等同于原始的上一次提交记录的拷贝，适用于远程仓库 远程 # 远程仓库本质是本地仓库在远程计算机上的拷贝/备份。\n强大备份 社交化 Git Clone 在本地创建一个远程仓库的拷贝 在本地仓库多了名为 origin/main 的分支，也叫远程分支 远程分支反映了远程仓库的状态 在切换到远程分支时，自动进入分离 HEAD 状态 \u0026gt; 远程分支命名规范 \u0026lt;remote_name\u0026gt;/\u0026lt;branch_name\u0026gt; origin/main:远程分支 main，仓库名 origin\nGit Fetch向远程仓库传输数据以及从远程仓库获取数据\n从远程仓库下载本地仓库缺失的提交记录 更新远程分支指针 通过http://或者git://与远程仓库通信 不会改变本地仓库 Git Pull 先抓取更新，再合并到本地分支(git fetch+git merge)\n实用指令 git pull --rebase 确保本地仓库与远程同步，才可以 Push\nGit Push 将变更上传到指定的远程仓库,并在远程仓库上合并你的新提交记录(发布成果) (这时候 main 分支和 origin/main 分支应该指向同一个记录)\ngit 区域 # 工作区 # 除了.git 隐藏目录以外，都属于工作区范畴 版本库(repository) # .git 隐藏目录是 Git 的版本库,版本库中有很多东西，最重要的是stage(index)，也就是暂存区，还有 Git 自动创建的第一个分支 master，以及指向 master 的HEAD 指针\n","date":"23 July 2025","externalUrl":null,"permalink":"/posts/git%E5%9F%BA%E6%9C%AC/","section":"Posts","summary":"\u003cp\u003e\u003cem\u003eGit\n\n  \u003cspan class=\"relative inline-block align-text-bottom icon\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 496 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z\"/\u003e\u003c/svg\u003e\n\n  \u003c/span\u003e\n\n 是什么?\u003c/em\u003e\u003c/p\u003e","title":"Git基本","type":"posts"},{"content":"","date":"23 July 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"23 July 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" ","date":"23 July 2025","externalUrl":null,"permalink":"/","section":"鲍宇翔的博客","summary":"\u003c!-- \u003cdiv class=\"lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl\"\u003e\n  欢迎！我是一名热爱计算机技术和软件开发的大学生，住在上海。\n\u003c/div\u003e\n --\u003e","title":"鲍宇翔的博客","type":"page"},{"content":"","date":"23 July 2025","externalUrl":null,"permalink":"/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","section":"Categories","summary":"","title":"软件工程","type":"categories"},{"content":"","date":"3 July 2025","externalUrl":null,"permalink":"/tags/%E5%AE%9E%E4%B9%A0/","section":"Tags","summary":"","title":"实习","type":"tags"},{"content":"","date":"3 July 2025","externalUrl":null,"permalink":"/tags/%E9%9A%8F%E6%84%9F/","section":"Tags","summary":"","title":"随感","type":"tags"},{"content":"","date":"3 July 2025","externalUrl":null,"permalink":"/categories/%E8%87%AA%E6%88%91/","section":"Categories","summary":"","title":"自我","type":"categories"},{"content":" 说来也怪，为什么突然想写博客了呢。\n一是可能确实距离上次写博客有一个多月的时间了，二是在学校没有课后，我真的在思考自己的人生和未来，也觉得自己学到了一些。 确实，5 月-6 月我花了差不多大半个月的时间投递简历，面试，最后一家 od 供应链公司给出了 oc。问清了是 Java 开发，符合我的预期，mentor 性格挺好的，也乐于带教，于是我就去了。 landing 前一周，并没有很多 coding的任务，大多数是在一个 java 项目里用 spring configuration 的一些注解读取配置类，然后在 yaml 文件里配置一些公司数据，就能自动取数，生成 excel 文件了，最后还要根据接口文档校对文件的表列名，没怎么写代码，倒是学了一下基础的 excel 操作。\n第二周逐渐开始熟悉公司业务，接了一个数据同步平台的项目，这个项目业务开始比较复杂了，属于公司内部人事管理系统，需要比较熟练的java Web Http 请求基础，以及序列化、反序列化的能力，用到 jackson 包，并且要熟悉 springboot 一些常用注解，和jpa等数据库访问的操作，需要比较好的面向对象封装能力。这三天还是比较锻炼我的，一个是锻炼阅读代码的能力，还有一个是自己的抗压能力，每天工作 8 小时几乎一直在看代码，从一点也不会的小白，一直问 mentor 问题，不断的 NullPointerException，到自己逐渐学会熟练 debugger，学会封装方法和类，异常处理，日志处理的能力，coding 能力所及绝对是有比较大的提升的。\n聊聊生活方面 # 公司的通勤稍微有点耗时，现在基本每天都要 7 点 15 分起床，8 点半前到公司，下午 5 点半下班，有时候会加班 10-20 分钟，但是 mentor 是不会催促我的，之前都是我自己心里觉得有活没干完不好意思走，所以自己加了会班，总体上，公司有比较严格的上班打卡制度和着装要求制度，以及直属领导脾气有点暴躁之外，其他地方还算好。环境处于市中心，整洁比较高档，楼下是商业街区，想要吃饭比较方便。\n我最近的感受是，自己每天都睡的很晚，最近有些焦虑，一是因为未来大四申请香港学校硕士的问题，我并不能保证自己一定能申请的上，且对于职业规划，我也不是百分百确定以后要当程序员，因为我在上海，本地公务员无论从薪资待遇还是压力上，都基本上优秀于私企员工。父母极力推崇公务员，所以我在考虑要不要将其作为未来规划准备。\n希望未来一个月，我能更好处理睡眠、学业、事业、生活等问题，尽量保证健康的同时，继续提升 coding 能力，准备开始刷算法题，积极逛一下开源论坛，争取能有 contribution。\n","date":"3 July 2025","externalUrl":null,"permalink":"/posts/%E6%9C%80%E8%BF%91%E5%AE%9E%E4%B9%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003e说来也怪，为什么突然想写博客了呢。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e一是可能确实距离上次写博客有一个多月的时间了，二是在学校没有课后，我真的在思考自己的人生和未来，也觉得自己学到了一些。\n确实，5 月-6 月我花了差不多大半个月的时间投递简历，面试，最后一家 od 供应链公司给出了 oc。问清了是 Java 开发，符合我的预期，mentor 性格挺好的，也乐于带教，于是我就去了。\nlanding 前一周，\u003cstrong\u003e并没有很多 coding\u003c/strong\u003e的任务，大多数是在一个 java 项目里用 spring configuration 的一些注解读取配置类，然后在 yaml 文件里配置一些公司数据，就能自动取数，生成 excel 文件了，最后还要根据接口文档校对文件的表列名，没怎么写代码，倒是学了一下基础的 excel 操作。\u003c/p\u003e\n\u003cp\u003e第二周逐渐开始熟悉公司业务，接了一个\u003ccode\u003e数据同步平台\u003c/code\u003e的项目，这个项目业务开始比较复杂了，属于公司内部人事管理系统，需要比较熟练的\u003cstrong\u003ejava Web Http 请求基础\u003c/strong\u003e，以及\u003cstrong\u003e序列化、反序列化\u003c/strong\u003e的能力，用到 jackson 包，并且要\u003cstrong\u003e熟悉 springboot 一些常用注解\u003c/strong\u003e，和\u003cstrong\u003ejpa\u003c/strong\u003e等数据库访问的操作，需要比较好的面向对象封装能力。这三天还是比较锻炼我的，一个是锻炼阅读代码的能力，还有一个是自己的抗压能力，每天工作 8 小时几乎一直在看代码，从一点也不会的小白，一直问 mentor 问题，不断的 NullPointerException，到自己逐渐学会熟练 debugger，学会封装方法和类，异常处理，日志处理的能力，coding 能力所及绝对是有比较大的提升的。\u003c/p\u003e","title":"最近实习的一些心得","type":"posts"},{"content":" 再见，大三和上课的日子！ # 是的，我的大三生活快结束了。\n本来以为大学四年是很长的一段时间，结果发现也不过如此，从 2022 年进入上海大学 SHU 修读计算机专业开始，转眼间已经接近三个年头了。回想起来这三年，似乎我学到了很多，成长了不少，又似乎抛弃了某些…\n从大一刚入学时候的迷茫，新鲜感，到大二逐渐熟悉校园生活，大三彻底明白了学校的各种制度和逻辑，仿佛大学对我来说只是相对于高中的一个不同环境而已。但是，真的是这样吗？\n2022.7，因为 COVID-19，我的高中有一大半的日子都在封锁、口罩中度过。高考结束的那天，似乎一切都到了一个终点。\n2022.9，搬着行李，从金山到宝山，我选了离家更远的这所 211。刚入学的时候面对什么都很兴奋，但回想起来那个时候我真是一个大 i 人。不过，我很开心自己能够在大一选择了很多社团，还加入了学院的信息部，认识了一堆有趣的朋友。\n我觉得大一的日子，是甜蜜的，有很多回忆值得珍藏，很多不舍，但对于CS的求学之路，大一基本上就是一个坑，让我错失了一年多的学习时间。其实这并不完全怪我，象牙塔里的人怎么能够了解外面的世界。大一的时候我只知道要好好准备期末考试，而其他时间玩就行了。高级语言程序设计我也有好好在学，可却落得了一个不理想的成绩。我觉得计算机不是我该学的学科，逐渐开始摆烂，对 CS 丧失了兴趣。\n大二的时候情况有所好转，从大一到大二我无论是在社交上，情感上，还是对于世界的理解上，都相比大一上升了几个台阶。这可能是得益于我喜欢探索新事物的原因。大二上有些事情不是很开心，有两个月我记得自己独自去健身房买了卡然后去跑步，一段时间后我遇到了我的女朋友。大学的体验卡基本上就到这里为止了。大二下，我去了一家迷你公司实习，什么都不会，这个时候的我，成绩和技术都比较差，好歹我有参加过蓝桥杯，刷过一点点算法，才不至于什么都不会。但也是这次实习摸鱼的过程中，我逐渐打开了计算机的大门。我知道学校里教的都是 20 年前老掉牙的技术，我知道绩点并不能够代表什么。我开始自学就业的技术，一开始也是从最快上手的 Node.js,Vue 入手，从前端三件套到了路由中间件。那个时候还没有前后端分离思想，还不懂任何设计模式，也不知道进程和线程的区别。但是在这一刻我觉得我算是入门了计算机，2024.9 月，我花了一个暑假实习，并回到了学校，我觉得我看待大学的视角不一样了。\n大三，生活上我有女朋友，让我的情绪变得非常稳定。我更加关注未来和就业相关的话题，我目前觉得，在尽可能的方面上多赚钱，多发挥自己的热爱，并且要享受年轻，用于去旅游，去追寻自己，这是我们 20 岁出头的年轻人应该干的事情。并且，大三我决定去读一年的港硕，这是一个比较大风险的决定，但是我觉得这可能是一次*锻炼自己综合能力大机会，同时也是在目前环境下快速获得高学历的一种捷径*，也可以说是一种交易/投资，综合来看，比在海内（大陆）读研更有优势，且作为就业缓冲期，更加更多校招机会。\n大三下有一段对自己未来不明确的迷茫时期。\n我觉得，当一个人不知道自己未来的时候，他是看不见路的，就像盲人一般，在黑夜里摸索，这样子是绝对找不到正确的出路的。\n我一直在想，前端 or 后端？我甚至还为此当上了小红书引流博主，发了一篇 1.7w+浏览量的引流贴，探讨前后端的各自优势，底下评论观点也各异。本来是打算要冲前端了，看到大佬Anthony Fu对这个行业的热爱，我不禁被感动。然而，我却没有继续选择前端。我询问了一位港中大的学长，他告诉我前端确实有职业瓶颈，而后端确实也是上升空间更大，但这要取决于职业规划，如果只是干几年程序员就跑路，那么选择前端可以用更低成本和难度进入大厂。综合考虑看，我选择了稳定性更高的后端。我觉得我做了一个正确的决定，我推掉了字节的前端一面邀约，相信这会是一个对的决定。\n2025 年的 5 月，我还在投递 Java 后端的岗位，这个学期在 6 月就结束了，之后大四一整年都是交给我去实习的日子。计算机学习的成本很低，有一台电脑就可以学，我看到了无数大佬们，都是在很小的时候就爱上了 coding，然后继续走下去这条路。我知道自己可能达不到他们的高度，自己也有可能在以后转行。但是我相信，“自己选择的路，结果也要由自己承担。”高中毕业时，家里人劝说我读法学，大学劝我考公，我知道这些职业固然稳定，但是不是我追求的方向，虽然说我也不可能去当一个音乐制作人（之前对这方面感兴趣），毕竟风险太高了，我也是一个求稳的人。但是，我仍旧记得高一的时候以梦为马（金山中学比我大两届的学长）的视频带给我的触动。\n2025.5.15，当下我已经考完了雅思，后端也已经学到了微服务，中间件，八股文也开始刷了，代码题也正在准备，我相信一切都在变好。\n所以，如果能重来一次？ # 如果能够回到 2022 年的秋天，我想我还是会这样，懵懵懂懂的过完大一，自己给自己买一个 20 岁的生日蛋糕。\n然后告诉自己：未来会更好。\n​\n","date":"15 May 2025","externalUrl":null,"permalink":"/posts/%E5%BF%AB%E8%A6%81%E7%BB%93%E6%9D%9F%E7%9A%84%E5%A4%A7%E4%B8%89%E5%92%8C%E6%9C%AC%E7%A7%91%E7%94%9F%E6%B6%AF/","section":"Posts","summary":"\u003ch3 class=\"relative group\"\u003e再见，大三和上课的日子！ \n    \u003cdiv id=\"再见大三和上课的日子\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e5%86%8d%e8%a7%81%e5%a4%a7%e4%b8%89%e5%92%8c%e4%b8%8a%e8%af%be%e7%9a%84%e6%97%a5%e5%ad%90\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cp\u003e是的，我的大三生活快结束了。\u003c/p\u003e\n\u003cp\u003e本来以为大学四年是很长的一段时间，结果发现也不过如此，从 2022 年进入上海大学 SHU 修读计算机专业开始，转眼间已经接近三个年头了。回想起来这三年，似乎我学到了很多，成长了不少，又似乎抛弃了某些…\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e从大一刚入学时候的迷茫，新鲜感，到大二逐渐熟悉校园生活，大三彻底明白了学校的各种制度和逻辑，仿佛大学对我来说只是相对于高中的一个\u003cstrong\u003e不同环境而已\u003c/strong\u003e。但是，真的是这样吗？\u003c/p\u003e\n\u003cp\u003e2022.7，因为 COVID-19，我的高中有一大半的日子都在封锁、口罩中度过。高考结束的那天，似乎一切都到了一个\u003ccode\u003e终点\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e2022.9，搬着行李，从金山到宝山，我选了离家更远的这所 211。刚入学的时候面对什么都很兴奋，但回想起来那个时候我真是一个大 i 人。不过，我很开心自己能够在大一选择了很多社团，还加入了学院的信息部，认识了一堆有趣的朋友。\u003c/p\u003e\n\u003cp\u003e我觉得大一的日子，是甜蜜的，有很多回忆值得珍藏，很多不舍，但对于\u003cstrong\u003eCS\u003c/strong\u003e的求学之路，大一基本上就是一个\u003cstrong\u003e坑\u003c/strong\u003e，让我错失了一年多的学习时间。其实这并不完全怪我，\u003cem\u003e象牙塔里的人怎么能够了解外面的世界\u003c/em\u003e。大一的时候我只知道要好好准备期末考试，而其他时间玩就行了。\u003cem\u003e高级语言程序设计\u003c/em\u003e我也有好好在学，可却落得了一个不理想的成绩。我觉得计算机不是我该学的学科，逐渐开始摆烂，对 CS 丧失了兴趣。\u003c/p\u003e","title":"快要结束的大三和本科生涯","type":"posts"},{"content":" 软工期末复习 # [TOC]\n第 1 章 软件工程学概述 # 开发人员对软件的认识存在偏差,传统制造业等其他工程学的思想应用在软件开发\n利用管理学的指导思想来指导软件开发,设计,系统与用户交互,软件测试,运维\n软件定义 # =软件是包括程序、数据及其相关文档组成的完整集合.=\n软件的特点 # 抽象特征 无明显制造特征 无备件特征 手工制作特征 成本昂贵 软件的分类 # 按软件功能分类\n系统软件 支撑软件 应用软件 按照规模划分…\n软件危机 # 开发与需求不匹配,研制周期长,正确性难以保证等,这些问题堆积起来成为了软件危机.\n解决的不是技术上的问题,是管理上的问题\n主要表现 # 用户需求不明确(甲方)、变更过多 软件成本日益增长 开发进度难以控制 软件质量差 软件维护困难 产生原因 # 软件开发无计划性 软件需求不充分 软件开发过程无规范 软件产品无评测手段 解决途径 # 应该加强软件开发过程的管理 推广使用开发软件的成功技术和方法 开发过程中使用好的工具 软件开发阶段 # 程序设计阶段 程序系统阶段 软件工程阶段 软件工程要素 # 三要素:方法、工具、过程\n软件工程目标 # 在给定成本、进度的前提下(开发人员等的工资),开发具有可修改性、有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性、可交互性并满足用户要求的软件产品.\n软件开发技术包含:\n软件开发方法学 软件工具 软件工程环境 软件工程管理 软件生存周期 # 孕育、诞生、成长、成熟、衰亡的过程\n计划 问题定义 可行性研究 开发 设计 需求分析(结果:需求规格说明书) 软件设计 总体设计 详细设计 实现 编码 测试 运行 维护 软件生存周期模型 # 从需求定义到使用废弃,全部过程、活动和任务的框架\n定义活动:做什么\n开发活动:怎么做\n维护活动:修改\n瀑布模型 # 顺序展开 每个阶段完成不会反工\n过早考虑程序实现\n必须每一阶段完成文档\n要求:需求稳定(不适应需求变化)\n螺旋模型 # 制作原型\n每旋转一圈开发一个版本\n有风险分析\n适合风险大、不一定能一次到位的软件\n第 2 章 可行性研究 # 问题定义 # 是软件工程第一个阶段,“需要解决什么问题”\n总体目标 功能和性能 可靠性和质量 是否具备可行的技术 当前市场和竞争对手 是否有成本和进度约束 将来可能进行哪些扩充 可行性研究的主要目的是用极少的代价在最短的时间内决定被开发的软件是否能开发成功\n经济可行性 技术可行性 法律可行性 运行可行性 主要工具 # ==系统流程图==:用黑盒方式描述系统各部件的流动情况,不对信息在系统中加工细节描述,所以不同于程序流程图.\n第 3 章 需求分析 # 需求分析主要目的是深入描述软件的功能和性能,确定软件设计的约束和软件同其他系统元素的**接口细节**,定义软件的其他有效需求(完全弄懂用户的所有需求)\n“系统做什么”的问题,不包括“怎么做”\n确定目标系统的具体要求 运行环境要求 性能要求 系统功能 分析系统的数据要求 建立目标系统的逻辑模型(理论上怎么实现,不考虑物理) 修正系统开发计划 建立原型系统 编写原型系统 编写软件需求规格说明书及评审 需求的获取 # 访谈和会议 市场调查 访问用户和用户领域的专家 考察现场,跟踪现场的业务流程 开发人员和用户共同组成联合小组 需求分析的过程 # 问题识别(系统分析员:程序员和用户的中间人) 系统分析员要研究可行性分析报告和软件项目实施计划(上一阶段),主要从系统的角度来理解软件,评审是否恰当.确定对目标系统的综合要求(=软件的需求),并提出这些需求实现条件,以及需求应达到的标准.也就是解决要求被开发的软件用来做什么,做到什么程度,\n持续到分析人员与用户双方都感到有把握正确的制定软件的需求规格说明为止\n防止堆栈效应:越早潜入的错误越晚被发现\n需求包含的内容 # 功能需求 性能需求 环境需求 可靠性需求 安全保密要求 用户界面要求 资源使用需求 软件成本消耗与开发进度需求 预期系统可达到的目标 快速原型方法 # 原型:软件早期的一个版本,能够反映最终系统的一部分特性\n快速分析构造出一个小型的软件系统,满足用户的基本要求;\n用户在试用原型系统过程中得到亲身感受和受到启发,做出反应和评价\n开发者根据用户的意见对原型加以改进,随着不断试验、纠错、使用、评价和修改,获得新的原型版本,如此周而复始,提高最终产品的质量.\n原型的分类 # 废弃型 系统构造好后原型系统被废弃\n追加型或演化型 先构想一个功能简单且质量要求不高的模型系统,最为最终系统的核心,然后通过不断的扩充修改发展为最终系统\n结构化分析方法 # 核心:数据字典\n数据建模 用数据描述现实世界的信息,ER 图\n功能建模和数据流 用抽象模型概念,按照软件内部数据传递、变化的关系,自顶向下逐层分解,直到找到满足功能要求的所有可实现软件 数据流图\n行为建模 给出需求分析方法的所有操作原则 状态-迁移图\n数据流图 # Data Flow Diagram,DFD,是用来描述软件系统逻辑模型的图形工具,用于描述信息在系统中流动和处理的情况.设计 DFD 只需考虑软件系统必须完成的逻辑功能“做什么”\n四种符号:\n数据流:数据流动的方向\n分层的时候:顶层图、一层图、二层图…\n父图和子图输入输出应该相等\n数据字典 # 数据字典（Data Dictionary,DD）是结构化分析方法的另一种有力工具,在数据字典中建立的一组严密一致的定义有助于消除分析员和用户之间的沟通障碍,因此将消除许多可能的误解.对数据的这一系列严密一致的定义也 有助于改进在不同的开发人员或不同的开发小组之间的通 信.同时,数据字典也是软件维护时使用的一种重要资料.如果要求所有开发人员都根据公共的数据字典描述数据和设计模块,则能避免许多麻烦的接口问题,提高开发的效率和质量.\n是根据数据流的\n内容:\n数据流词条描述 数据项词条描述 数据文件词条描述 加工逻辑词条描述 源点及汇点词条描述 数据流+数据存储+数据项(不可分解)\n= 定义\n+号 与…组成\n[] | 组成\n{} 重复 由 0 个或多个\n() 可选 可以出现或不出现\nm{}n 可出现 m-n 次\n“…” 表示取…值的数据元素\n.. 连接符 x=1..9 中任意一个\n需求分析评审 # 确定需求规格说明书,是双方达成的协议书\n需求分析实例 # 数据流图:\n顶层图、一层图、二层图(自顶向下分解)\n数据来源:外部实体\n第 4 章 形式化说明技术 # 不考,无资料\n第 5 章 总体设计 # 现在是到了软件设计阶段,上一阶段得到的结果是需求规格说明书,明确的描述了用户对系统的需求,现在要解决“怎么做”的问题\n将软件需求转换为软件的表示过程\n概要设计(总体):将软件需求转换为软件结构和数据结构,并编写概要设计说明书\n详细设计:通过对软件结构的细化,得到软件的详细算法和数据结构,产生描述软件的详细设计文档\n软件设计的基本概念 # 逐步求精 先定义边界,再将功能拆解为若干个组合模块,越往下越细化,抽象性,每一个阶段都是对上一个阶段的求精.(可行性阶段,需求分析阶段,设计阶段,编码阶段) 程序结构 划分模块,模块和模块之间的关系 数据结构 是构成复杂结构的基本块 局部化 将关系密切的元素靠近一些,有利于实现信息隐蔽,方便用户调用 模块化 # 模块是数据说明、语句等程序对象的集合,单独命名而且可以通过名字来访问,如**过程、函数、子程序、宏**\n模块 3 个基本属性 # 功能:模块实现的功能(含子模块) 逻辑:模块内部怎么做 状态:模块使用时的环境和条件 模块具有内部和外部两个特性:\n外部特性:模块的名字、参数等 内部特性:完成模块功能的程序代码和模块内部数据 模块的独立性 # 软件系统中每个模块只涉及软件要求的具体子功能,而和软件系统中其他的模块**接口是简单的**\n模块独立性高的软件容易开发,便于多人合作 独立模块容易测试和维护 一般采用两个准则度量模块独立性,即==模块与模块之间的耦合度==和==模块内部的内聚性== 耦合性 # 耦合是程序结构内不同模块之间相互关联的度量.它是由模块间接口的复杂程度、调用模块的方式及通过接口传递的信息类型决定的.\n模块之间的连接越紧密,联系越多,耦合性越高,而其模块独立性越弱\n非直接耦合 如果两个模块之间没有直接关系,联系通过主模块的控制和调用实现的,这就是非直接耦合,模块独立性最强.\n数据耦合 模块访问另一个时,彼此之间通过**数据参数(**不是控制参数、公共数据结构或外部变量)来交换输入、输出信息,为数据耦合.\n限制了只通过参数表传送数据,所以按数据耦合开发程序接口简单,安全可靠.\n数据耦合是松散的耦合,模块之间的独立性比较强.在软件设计中多用这种耦合.\n特征耦合 如果一组模块通过参数表传递记录信息,就是特征耦合.\n事实上,这组模块共享了某一数据结构的子结构,而不是简单变量.这就要求这些模块都必须清楚该记录的结构.\n控制耦合 如果一个模块通过传送开关、标志、名字等控制信息,明显地控制选择被调用模块的功能,则称这种耦合为控制耦合.\n实质是在单一接口上选择多功能模块中的某项功能.因此,对被控模块的任何修改,都会影响控制模块.另外,控制耦合也意味着控制模块必须知道被控模块的内部逻辑,这些会降低模块的独立性.\n外部耦合 一组模块都访问同一全局简单变量而不是同一全局数据结构,而且不是通过参数表传递该全局变量,则称为外部耦合.外部耦合引起的问题类似于公共耦合,区别在于外部耦合不依赖于一个数据结构内部各项的程序逻辑.\n公共耦合 若一组模块都访问同一个公共数据环境,则它们之间的耦合就称为公共耦合.公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等.\n内容耦合 如果一个模块直接访问另一个模块的内部数据;或者一个模块不通过正常入口转到另一模块内部;或者两个模块有一部分程序代码重叠;或者一个模块有多个入口,则两个模块之间就发生了内容耦合.\n在内容耦合的情况下,被访问模块的任何变更,或者用不同的编译器对它再编译.都会造成程序出错.这种耦合是模块独立性最弱的耦合.\n内聚性 # 标志一个模块内部各元素彼此结合的紧密程度\n偶然内聚 程序内几个模块内凑巧有一些程序段代码相同,又没有明确表现出独立的功能,这些代码独立出来建立的模块称为偶然内聚\n逻辑内聚 一个模块几种相关的功能组合在一起,每次被调用时,由传送给模块的控制参数来确定模块应该执行哪种功能.逻辑内聚导致模块间的控制耦合\n时间内聚 时间内聚大多为多功能模块,要求模块的各个功能必须在同一时间段内进行,如初始化模块或结束模块.在一般情形下,各部分可按任意的顺序执行,所以它的内部逻辑更简单.\n过程内聚 如果模块内的处理是相关的,并且必须以特定顺序执行.\n使用流程图作为工具设计工具时,常常通过流程图去确定模块划分.把流程图某一部分划出独立模块,就得到过程内聚模块.\n通信内聚 一个模块内各部分功能都使用了相同的输入数据,或者产生了相同的输出数据,则称之为通信内聚模块,通常通信内聚模块是通过==数据流图==来定义的.\n信息内聚 模块完成多个功能,各个功能都在同一数据结构上操作,每一项功能都有一个唯一的入口点,信息内聚模块可以看成是多个功能内聚模块的组合,并且实现信息上的隐蔽.\n即把某个数据结构、资源或设备隐蔽在一个模块内,不为别的模块所知晓.这种封装增加了模块的独立性\n功能内聚 一个模块的各个功能都是完成某个具体任务必不可少的,这些成分协同工作,紧密联系,不可分割.\n功能内聚的内聚度最高,满足功能内聚的模块执行一个功能,这是判断模块是否是功能内聚的一个方法.\n抽象 # 抽象(Abstration)就是提取出事物的本质特征而暂时不考虑它们的细节.\n在软件设计中,涉及到众多的物理元素,如果一开始就考虑细节问题,不可能做到精确思维.抽象化对于软件设计十分重要.\n软件设计中可以有不同的==抽象层次==,最高层次抽象上,用问题所处环境的语言,概括描述问题的解答.在最低层次,用直接实现的方式来描述问题的解答.\n抽象三个层次 # 过程抽象 从问题定义到程序的实现(代码),每个步骤逐步细化;抽象层次逐渐降低\n数据抽象 在不同抽象层次上描述数据对象的细节,数据抽象把一个数据对象的定义抽象为一个数据类型名.(比如定义一个人的时候 Person 为相同性质一堆人的抽象)确定实体和对应的操作\n控制抽象 可以包含一个程序控制机制而无需规定其内部细节.(操作系统中协调活动的同步信号)\n信息隐蔽:目的是提高模块的独立性,(信息内聚),不要把 A 模块的错误扩散到其他 B 模块.\n软件设计的基本原则 # 功能分解 设计对分析模型是可跟踪的 设计结构应尽可能模拟实际问题 设计应该表现出一致性 不要把设计当成编写代码 创建设计时就应该能够评估质量 设计阶段注重软件的重用 评审设计以减少语义性的错误 结构化设计方法 SD # 面向数据流的设计方法,基于模块化,自顶向下逐层细化\n基于数据流图审查和分析,改进细致处理,生成对应数据字典\n系统结构图 SC # Structed Chart 是 SD 方法使用的主要描述工具,描述**软件的组成模块和调用关系**\n由四个模块组成:传入模块,传出模块,变换模块,协调模块\n简单调用 选择调用 循环调用 所有 DFD 结构可以分为:变换型,事务型\n变换型结构==输入数据、变换数据、输出数据== 事务型结构 ==有明显事务中心== 变换分析 # 将变换型数据流图映射为软件结构图一系列步骤总称\n==重新画数据流图==,不要出现控制逻辑,箭头表示数据流向\n这个图有中心变换部分,所以是变换型的\n将数据流图转换为软件结构图,建立总控模块\n第 6 章 详细设计 # 上面的软件结构还不够实现开发,需要进行详细设计,例如程序流程图\n箭头流向表示程序执行顺序,菱形表示判断和选择\n盒图(程序设计)(Box-Diagram)(N-S 图) # N-S 图也称盒图,是一种符合结构化程序设计原则的图形描述工具.\n结构化程序设计要求只使用 3 种基本控制结构,即顺序结构、分支结构(简单选择型和多分支选择型)和循环结构(包括先判定型和后判定型)\n每个矩形框都是明确定义的功能域 控制转移不能任意规定,必须遵循结构化程序要求 很容易确定局部数据和全局数据的作用域 很容易表现嵌套关系和模块的层次结构 PAD(Problem Analysis Diagram)问题分析图 # 日本公司提出的结构化程序设计思想表现程序逻辑结构的图形工具\n也设计了 5 种基本控制结构的图式,并允许递归使用\n判定树\u0026amp;判定表 # 当算法中包含**===多重嵌套的条件选择==时,用程序流程图、 N-S 图或 PAD 都不易清楚地描述.这时可以用 或判定树来描述这些复杂的条件.判定表与判定树除了在详细设计阶段使用外,在需求分析阶段也经常使用.判定表一般由4 部分组成**：左上半部分列出所有条件、 左下半部分列出所有动作、右上半部分列出各种条件组合,右下半部分列出和每组条件取值组合对应的动作.\n判定表的优点是能够简洁,无二义性的描述所有的处理规则。缺点是它所表示的是静态逻辑，是在某种条件组合情况下可能的结果，它不能表达加工的顺序,也不能表达循环结构.因此，判定表不能成为一种通用的设计工具,一般作为辅助工具配合其他工具一起使用。\n判定树\n判定树是判定表的变形,本质一样.\n优点:形式简单、比较直观、易于掌握和使用,缺点是不如判定表简洁\n第 7 章 实现 # 编码风格 # 编码风格的作用就是使==代码容易读==； 风格良好的代码更容易阅读和理解，错误更少； 使用一致和有意义的标识符名 用缩进显示程序结构 用加括号的方式排除二义性 避免大量使用循环嵌套和条件嵌套 当心运算符的副作用 把数定义成常量 利用 sizeof()计算对象的大小 清晰的代码，而非最巧妙的代码 程序的注释 序言性注释和功能性注释 对一段程序注释，而不是每一个语句 使用数据结束标记（EOF、BOF），不要指定数据的数目来判断文件的结束。 测试 # 测试的==目的==就是在软件投入==生产性运行==之前，尽可能多地==发现软件中的错误==。\n调试的==目的==是**==诊断并改正==错误，由程序员完成。**\n对软件规格说明、设计和编码的最后复审。\n开发总工作量的 40%以上，极端情况下，其他开发步骤总成本的3 倍到 5 倍。\n测试是为了发现程序中的错误而执行程序的过程。\n好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案。\n成功的测试是发现了至今为止尚未发现的错误的测试。\n测试只能查找出程序中的错误，不能证明程序中没有错误。\nPareto 原理：80%的错误很可能是 20%的模块造成的。从“小规模”测试逐步到“大规模”测试。\n穷举测试是不可能的。\n为了达到最佳的测试效果，应该由独立的第三方从事测试工作。\n测试方法 # ==黑盒==测试：又称功能测试或数据驱动测试 ==白盒==测试：又称结构测试或逻辑驱动测试 黑盒测试 # 功能测试或数据驱动测试（问诊）\n等价划分 把输入域分为数据类，取每类的一个典型值进行测试 新增测试用例尽可能多地覆盖尚未被覆盖的有效等价类 新增测试用例覆盖一个尚未被覆盖的无效等价类 边界值测试 着重测试输入等价类和输出等价类的边界，选取的测试数据应该刚好等于、刚好小于和刚好大 于边界值 用等价划分和边界值分析法设计测试用例 等价划分\n把程序的输入域划分成若干个==数据类==，每类中的一个典型值在测试中的作用与这一类中所有其他值的作用相同。据此导出测试用例。 设计测试用例 (1) 设计一个新的测试方案以尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步骤直到所有有效等价类都被覆盖为止； (2) 设计一个新的测试方案，使它覆盖一个而且只覆盖一个尚未被覆盖的无效等价类，重复这一步骤直到所有无效等价类都被覆盖为止。 边界值分析\n着重测试输入等价类和输出等价类的边界，选取的测试数据应该刚好等于、刚刚小于和刚刚大于边界值。 要求:会用==等价划分==和==边界值分析法==设计测试用例\n白盒测试 # 结构测试或逻辑驱动测试（手术） 以程序内部逻辑结构为基础的设计测试用例的技术 语句覆盖：每个语句至少执行一次 判定覆盖（分支覆盖）：每个判定的每个分支至少执行一次 条件覆盖：每个判定的每个条件都取到可能的值，每个判定的分支至少执行一次\n条件组合覆盖：每个判定中的各种条件组合都至少执行一次（对源程序语句检测详尽程度最高） 点覆盖、边覆盖、路径覆盖（顾名思义）\n白盒测试技术：逻辑覆盖\n定义：以==程序内部的逻辑结构为基础的设计测试用例==的技术\n类型\n语句覆盖：选择足够多的测试数据，使被测程序中每个语句至少执行一次。\n判定覆盖：判定覆盖又叫分支覆盖，选择足够多的测试数据使每个判定的每个分支都至少执行一次。\n条件覆盖：选择足够多的测试数据使每个判定表达式中的每个条件都取到各种可能的结果\n判定／条件覆盖：选取足够多的测试数据，使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果。\n条件组合覆盖：选取足够多的测试数据，使得每个判定表达式中条件的各种可能组合都至少出现一次。(最好)\n要求:设计测试用例（==会做==）\n可以把「黑盒测试」和「白盒测试」想象成买东西时的两种“体验”： 1. 黑盒测试就好比你买了一个手机，只关注它能不能正常打电话、拍照、上网，不关心它内部的芯片、电路是怎么工作的。 • 测试时，你只需要根据需求或者说明书来试一下各种功能：比如能不能拨打电话，能不能拍照，能不能用微信等。 • 你并不用去了解它是如何编程实现的，也不用查看源代码，只要功能“用起来”符合要求就行。 2. 白盒测试则像你是个电子工程师或手机设计师，知道手机里每块芯片、每行电路的具体功能，你会检查它们是不是都正确地运转。 • 测试时，你需要查看手机内部的工作原理，比如 CPU 各个功能模块有没有正确执行，或者手机系统软件中每个函数、每条分支都有没有被测试到。 • 你不只是看“能不能打电话”，你还会看代码里“如果没插卡时，程序是不是应该给出提示？”、“所有条件分支是不是跑了一遍？”等等。\n总结：黑盒测试只关心“外在表现”（功能是否正确），白盒测试则还要研究“内部结构”（代码或逻辑是否正确）。\n测试步骤 # 模块测试（单元测试） 在这个测试步骤中所发现的往往是编码和详细设计的错误 子系统测试 模块放在一起形成一个子系统来测试 着重测试模块的接口 系统测试 经过测试的子系统装配成一个完整的系统来测试 发现的往往是软件设计中的错误，也可能发现需求说明中的错误 验收测试（确认测试） 它的目标是验证软件的有效性（如果软件的功能和性能如同用户所合理期待的那样，软件就是有效的） 用户积极参与，可能主要使用实际数据进行测试 发现的往往是系统需求说明书中的错误 平行运行 回归测试 # 回归测试是指重新执行已经做过的测试的某个子集，以保证变化（程序改错、新模块加入等）没有带来非预期的副作用。\nAlpha 测试 在开发者的“指导”下，由用户在开发场所进行。 Beta 测试 多个用户在实际使用环境下进行测试。 集成测试方法 # 非渐增式集成 先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序。 先进行单元测试，再进行集成测试 渐增式集成 将单元测试与集成测试结合在一起，把下一个要测试的模块同已经测试好的那些模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。 自顶向下（Top-Down）集成 自底往上（Bottom-Up）集成 三明治式（Sandwich）集成 几种集成测试方法的优缺点 # 第 8 章 维护 # 所谓软件维护就是在软件已经交付使用之后，为了改正错误或满足新的需要而==修改软件==的过程。保证软件在一个相当长的时期能够==正常运行==。\n60%以上, 这个百分比还在持续上升。\n维护类型 # 改正性维护\n诊断和改正错误的过程。17%～ 21%\n适应性维护\n为了适应环境的变化进行的修改软件的活动。 18%～ 25%\n完善性维护\n增加新功能或修改已有功能。 50%～ 66%\n预防性维护\n为了改进未来的可维护性或可靠性，或为了给未来的改进奠定更好的基础而修改软件。4%左右\n软件的可维护性 # 维护人员理解、改正、改动或改进这个软件的难易程度。\n提高可维护性是支配软件工程方法学所有步骤的关键目标。\n决定软件可维护性的因素\n1）可理解性\n2）可测试性\n3）可修改性\n4）可移植性\n5）可重用性\n第 9 章 面向对象方法学引论 # 基本概念 OOP 学过了,差不多都会\n$$ 面向对象=对象+类+继承+消息通信 $$对象:为它本身的一组属性和它可执行的一组操作\n类:一组具有相同数据结构和相同操作的对象的集合\n继承:从已存在的类为基础建立新类的技术\n应用生存期 # 瀑布模型是生存期模型.\n面向对象开发步骤:\n分析阶段 高层设计 类的开发 实例的建立 组装测试 应用与维护 上一个阶段的成果作为下一阶段的基础\n类生存期 # 在面向对象技术中，类是作为一个单元存在的。不断有新的类在系统开发的各个阶段被标识，但在各个阶段的类所起的作用是不同的。类的开发有如下几个步骤：\n类的规格说明 设计 实现 测试 求精和维护 UML(Unified Method Language)统一建模语言 # 工具:建模面向对象技术的==标准==语言\nUML 是一种可视化的、用于绘制==软件蓝图==的标准建模语言。可以用 UML 对软件系统的各种制品（包括程序、文档等）进行描述。\nUML 作为一种语言提供了用于交流的词汇表和使用这些词汇的规则，它由一些符号和一套指示如何使用这些符号的规则构成，可以利用这些明确定义的符号和相应的规则，建立待开发系统的各种模型。\n利用面向对象技术为系统建模 易于使用、表达性强,进行可视化建模 与具体实现无关,适用于任何语言和平台 具有较强的适用性和可扩展性 使用面向对象技术设计系统时，首先是描述需求。其次根据需求建立系统的静态模型，构造系统的结构。这两步所建立的模型都是静态的，属于==UML 中的静态建模机制==。 第三步是描述系统的行为。这一步骤中建立的模型或者可以执行，或者表示执行时的时序状态或交互关系，是标准建模语言 UML 的==动态建模机制==。 因此，标准建模语言 UML 的主要内容也可以归纳为静态建模机制和动态建模机制两大类。\nUML 三个主要要素 # UML 基本构造块 控制构造块如何组合的规则 作用域 UML 模型的通用机制 按照层次结构划分,UML 基本构造块包含:\n视图(View) 图(Diagram) 模型元素(Model Element) 视图 # 视图是用来显示系统的不同方面。视图并不是图形（Graph），而是由多个图（Diagram）构成的，是在某一个抽象层上对系统的一个抽象表示。\n用例视图 逻辑视图 并发视图 组件视图 部署视图 图 # 图用来描述一个特定视图的内容。 UML 中的图由各种图形构成，图形就是各种模型元素符号。UML 提供了静态图和动态图两大类共 9 种图，用来描述系统的所有视图。\n静态图\n包括==用例图==、==类图==、==对象图==、组件图和部署图 动态图\n包括==状态图==、==时许图==、协作图和活动图 UML 模型元素\u0026amp;表示方法 # 在 UML 各种图中使用的概念统称为模型元素。模型元素主要是用标准的图形符号表示的，图形符号本身代表了 UML 的语法。由这些==图形符号==组成的各种模型，则给出 UML 的语义。\n第一类模型元素(图形)表示某个概念 类、对象、组件、状态、用例(用户（或其他系统）与目标系统之间的一种交互场景)、结点、接口、包、注释等 第二类表示模型元素之间相互连接的关系(关系也是模型元素) 关联、泛化、依赖、聚集 UML 元模型结构 # UML 模型按照语义可定义为 4 个抽象层次。从低到高分别是元元模型、元模型、模型和用户模型。下一层是上一层的基础，上一层是下一层的实例。\n示例\n包 # 可将==许多类==集合成一个更高层次的单位， 形成一个高内聚、低耦合的类的集合。UML 把这种将一些模型元素组织成语义上相关的组的分组机制叫包 （Package）。 包中的所有模型元素叫作包的内容。包有时也称子系 统，常用于对模型的组织管理。包的实例没有任何语义，仅在模型执行期间，包才有意义。 包与包之间可以有关系，允许的关系有：依赖、细化和 泛化。\nUML 扩展机制 # 构造型 标记值 约束 UML 的规则 # UML 就是一种由符号和一套指示如何使用这些符号的 规则组成的建模语言。其中，符号就是在模型中使用的符号，规则包含语法规则、语义规则和实用规则。\n命令:为模型起一个名字 范围:给模型元素上下文 可见性:让其他元素看见此元素 完整性:各模型如何正确一致联系 执行:运行或模拟动态模型的含义是什么 静态建模 # 静态模型-==用例模型== # 由一组用例图组成，其基本组成部件是==用例、角色和系统==。用例是系统中的一个功能单元，是对系统的一个 用法的通用描述。用例描述的是系统的总体功能。用例之间的关系主要有 3 种：泛化关系、扩展关系和包含关系。\n人:具体角色/系统,是==执行用例的主体==(参与者)\n圆圈:具体的==用例==表示系统的==功能单元==\n圆圈之间:==泛化(Generalization)==关系、==扩展(extends)==关系、==包含(includes)==关系\n在软件工程和 UML（统一建模语言）中，用例之间常见的三种关系是：\nInclude（包含） • 用例 A 在执行过程中“包含”了用例 B，意味着 A 的部分流程需要调用（或复用）B 的功能。\n• 使用场景：当多个用例都会用到同一段通用逻辑时，可以把这段逻辑抽取成一个独立的用例 B，再由其他用例通过 include 的方式来调用它。\n• 特点：被包含的用例是必要的，不执行 B 用例便无法完成 A 的完整流程。\nExtend（扩展） • 用例 A 在某个条件下被用例 B “扩展”，即在 A 的基础流程里，若满足某些条件，会触发 B 的额外步骤或不同分支。\n• 使用场景：当你想在 A 用例的基础流程上，针对特定的情况或条件，增加额外处理或改变流程，而这部分逻辑并非所有情况下都执行。\n• 特点：被扩展的用例是可选的，仅在满足扩展条件时才会发生。\nGeneralization（泛化/继承） • 用例 A 是用例 B 的“泛化”或“子用例”，表示 A 继承了 B 的主要流程，并可在其中增补或修改特定步骤。\n• 使用场景：当多个用例有相同的大部分流程，但在细节或约束上略有不同时，可以让子用例继承父用例的大部分描述，并在子用例中做针对性扩展或重写。\n• 特点：父用例抽象了共同行为，子用例可覆盖或补充父用例的部分流程。\n总结：\n• Include 侧重于将公共或必需的功能拆分，减少重复。\n• Extend 适用于条件下的可选或额外流程。\n• Generalization 适用于同一功能族中不同用例间的继承与差异化。\n这三种关系能帮助我们在用例图中更好地表达各用例间的复用、扩展以及层次结构，从而让需求和设计更加清晰。\n用例模型在需求分析阶段进行\n静态模型-==类和对象模型== # 在 UML 中，类和对象模型分别由类图和对象图表示。类是用一个矩形表示的，并且该矩形由 3 部分组成：名称部分、属性部分和操作部分。\n对象与类具有相同的表示形式。对象图可以看作是类图的一个实例；对象之间的链是类之间相互关联的实例。对象与类的图形表示相似。\n类之间的关系 # 关联关系 菱形放在包含(多)的一端\n聚集关系 泛化关系 依赖关系和细化关系 动态建模 # 消息 # UML 的 4 个动态模型均采用消息这个概念。对象通过相互间的通信（消息传递）进行合作，并在其生命周期中根据通信的结果不断改变自身的状态。\n动态模型-==状态图== # 用来描述一个特定对象的所有**可能状态及引起其状态转移**的事件。一个状态图包括一系列的状态以及状态之间的转移。\n状态 状态转移 事件(箭头) 状态图之间发送消息 动态模型-时序图 # 用来描述对象之间动态的交互关系，着重体现对象间消息传递的时间顺序。 时序图存在两个轴：水平轴表示不同的对象，垂直轴 表示时间。时序图中的对象用一个带垂直虚线的矩形框表示，并标有对象名和类名。垂直虚线是对象的生命线， 用于表示在某段时间内对象是存在的。对象间的通信通过在对象的生命线间传递消息来表示。消息的箭头指明消息的类型。\n![截屏2025-03-09 16.28.24](/assets/截屏 2025-03-09 16.28.24.png)\n协作图:相互协作对象交互关系和链接关系,着重体现交互对象静态链接关系\n活动图:显示动作及其结果,通过对象图状态变化来获取动作和结果.\n第 10 章 面向对象分析 # 面向对象分析(OOA,Object-Orientied Analysis):面向对象分析最后得到的是对==问题论域的清晰、精确的定义==。属于软件开发过程中的==问题定义阶段==，产生==描述系统功能==和==问题论域==的基本特征的综合文档。\n论域分析 # Domin Analysis:在一个更广泛的领域考虑问题,把相关的概念都标识到,以便把核心知识掌握得更好\n语义数据模型(semantic data model) ==3 层模型== 外部模型 概念模型 内部模型 在语义数据模型中的关系 标识对象和类 标识联系 应用分析 # 论域分析时建立起来的问题论域模型是应用分析的依据，要把它们用于当前正在建立的系统当中。在应用分析阶段产生影响的条件则伴随用某种基于计算机系统的程序设计语言来表示。重点考虑应用视图和类视图。必须详细描述对每个类的规格说明和操作，同时表示形成系统结构的类之间的相互作用。\n对象模型技术 OMT(Object Model Technology) # 把分析时收集信息构造在 3 类:对象模型、动态模型、功能模型\n这个模型化的过程是一个迭代的过程。每一次迭代都将对这 3 个模型做进一步的检验、细化和充实。\n对象模型 # 它的作用是描述系统的静态结构，包括构成系统的类和对象，它们的属性和操作，以及它们之间的联系。\n对象图是类图的细化\n“用例”所描述的功能 ≈ “对象模型中某些类所提供的服务”\n属性:描述静态特征\n方法/操作:描述动态特征\n也可以使用==整体和实例进行组合/聚合技术==来描述面向对象分析\n建立对象模型的步骤:\n确认对象和类 建立数据字典 加入对象间的关联 确认对象属性 使用继承加强类之间的联系 确定存取数据的可能路径 反复修正对象模型 动态模型 # 系统的涉及时序和改变的状况，可用动态模型来描述。 动态模型着重于系统的控制逻辑。它包括两个图：状态图、事件追踪图。\n建立动态模型步骤:\n确认事件记录 确认对象的事件 准备每个程序事件追踪图 确保对象间事件的一致性 功能模型 # (e.g 系统流程图就是功能模型,可行性研究阶段)\n功能模型着重于系统内部数据的传送和处理。功能模型由多个数据流图组成，它们指明从外部输入，通过操作和内部存储，直到外部输出的整个的数据流情况。\n建立功能模型步骤:\n确定输入和输出数据 建立每个系统的功能 确认对象间的限制 详述最优系统分析准则 第 11 章 面向对象设计 # 高层设计 # 高层设计开发系统的结构，用来构造系统的总体模型，并把任务分配给系统的各个子系统。\n最小化构件间通信(高内聚,低耦合) 隐藏复杂性 逻辑功能分组 类的设计 # 核心原则:通过==复用==去设计类\n选择、分解、配置、演变\n应用系统的实现是在所有的类被实现之后完成的\n软件复用 # 用现有的软件成分构造新的软件系统,包括两方面\n开发软件构件的技术 使用软件构件的技术 e.g.活字印刷=\u0026gt;每一个文字都进行抽取,只需要后续进行排版、组装\n软件复用的范围不仅涉及源程序代码，还包括==体系结构==、 ==需求模型==和==规格说明==、==各种设计==、==用户界面==、==数据==、==测试用例==、==用户文档==和==技术文档==，还有==项目计划==、==成本估计==等。将这些软件制品分为以下几类：\n源代码复用 软件体系结构复用 应用程序生成器 特定论域的软件体系结构的复用 论域工程 # 通过领域分析找出最优复用,设计构造成可复用构件,建立大规模的软件构件仓库的过程\n应用系统工程 # 通过复用构件系统开发某个特定应用系统的构件工程称为应用系统工程(ASE)\n","date":"7 March 2025","externalUrl":null,"permalink":"/posts/%E8%BD%AF%E5%B7%A5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/","section":"Posts","summary":"\u003ch1 class=\"relative group\"\u003e软工期末复习 \n    \u003cdiv id=\"软工期末复习\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e8%bd%af%e5%b7%a5%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003e[TOC]\u003c/p\u003e\n\n\u003ch2 class=\"relative group\"\u003e第 1 章 软件工程学概述 \n    \u003cdiv id=\"第-1-章-软件工程学概述\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e7%ac%ac-1-%e7%ab%a0-%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%ad%a6%e6%a6%82%e8%bf%b0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e开发人员对软件的认识存在偏差,传统制造业等其他工程学的思想应用在\u003ccode\u003e软件开发\u003c/code\u003e\u003c/p\u003e","title":"软件工程期末复习","type":"posts"},{"content":"","date":"14 December 2024","externalUrl":null,"permalink":"/tags/css/","section":"Tags","summary":"","title":"Css","type":"tags"},{"content":" Taiwindcss # 用于 react 的 application ui 组件库 Installation # 不使用 React # 创建 tailwind.config.js file 和 download\nnpm install -D tailwindcss npx tailwindcss init 在配置文件中添加模板文件路径\n/** @type {import(\u0026#39;tailwindcss\u0026#39;).Config} */ module.exports = { content: [\u0026#34;./src/**/*.{html,js}\u0026#34;], theme: { extend: {}, }, plugins: [], } 在主 css 文件添加@taiwind 指令\n@tailwind base; @tailwind components; @tailwind utilities; 完成，可以在 html 中使用 taiwind 添加 class 类名了\n如果使用 Vite 驱动框架： # npm install tailwindcss@next @tailwindcss/vite@next 在 vite.config.ts：\nimport { defineConfig } from \u0026#34;vite\u0026#34;; import tailwindcss from \u0026#34;@tailwindcss/vite\u0026#34;; export default defineConfig({ plugins: [tailwindcss()], }); 导入主 css 文件：\n@import \u0026#34;tailwindcss\u0026#34;; 使用 React # /** @type {import(\u0026#39;tailwindcss\u0026#39;).Config} */ module.exports = { content: [\u0026#34;./src/**/*.{js,jsx,ts,tsx}\u0026#34;], theme: { extend: {}, }, plugins: [], }; 在 css 中：\n@tailwind base; @tailwind components; @tailwind utilities; bg color # 不同灰度级的背景色调色盘\ncss 类:bg-black/white/slate(偏蓝灰)-(100-950),gray, zinc(纯灰),neutral, stone,red,orange,amber,lime\u0026hellip;.\n设置不透明度：e.g. bg-sky-500**/100,75,50**\n其他状态：hover:b-cyan-600\nw # w-4 代表1rem\nw-1 0.25rem\nw-px 使用像素\nw-1/2 分数设置百分比\nw-full 全宽\nw-screen 视口宽度\nmin-w- 最小宽度\n媒体查询md:min-w-0 在中等屏幕尺寸下应用\nh # 与 w 同理\nh-dvh 动态视口高度\nh-lvh 最大视口高度\nh-svh 最小\nsize # 与 w，h 同理，同时设置 wh\ntext # xs，sm，base，lg，xl，2xl，4xl\nfont-bold\nrounded # =border 同 text\nflex # flex 设置为弹性布局\nflex-row flex-col 设置主轴\nflex-wrap 换行\njustify-center 沿主轴居中\njustify-between/around/evenly\nitems-center\u0026hellip;\ngap 设置子元素艰巨\nm # 设置 margin\nmx-4 my-4 水平和垂直方向\nmt mr mb ml 上下左右方向\n-m-4 负值\np # 设置 padding\n同 m\ntransform # Transform 设置变换效果\ntranslate 平移 -x-4 -y-2\nrotate-45 顺时针\nscale-110 缩放 1.1 倍\nskew-x-12 倾斜度数\ntransition # transition 过渡\ntransition-colors 渐变颜色\ntransition-transform 变换相关属性进行过渡\nduration-300 持续时间 300ms\nease-in/out/in-out 缓动函数\ndelay-200 延迟 ms\nanimation # animation-ping 逐渐淡出\n-bounce 弹跳动画\n-spin 旋转动画\n-pulse 呼吸动画\n响应式 # sm: md: lg:\n状态类 # hover: active: focus:\n","date":"14 December 2024","externalUrl":null,"permalink":"/posts/taiwind-css%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","section":"Posts","summary":"\u003ch1 class=\"relative group\"\u003eTaiwindcss \n    \u003cdiv id=\"taiwindcss\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#taiwindcss\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e用于 react 的 application ui 组件库\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 class=\"relative group\"\u003eInstallation \n    \u003cdiv id=\"installation\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#installation\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\n\u003ch4 class=\"relative group\"\u003e不使用 React \n    \u003cdiv id=\"不使用-react\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e4%b8%8d%e4%bd%bf%e7%94%a8-react\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h4\u003e\n\u003cp\u003e创建 tailwind.config.js file 和 download\u003c/p\u003e","title":"TailwindCSS基本使用","type":"posts"},{"content":"","date":"14 December 2024","externalUrl":null,"permalink":"/categories/%E5%89%8D%E7%AB%AF/","section":"Categories","summary":"","title":"前端","type":"categories"},{"content":"","date":"14 December 2024","externalUrl":null,"permalink":"/tags/%E5%89%8D%E7%AB%AF/","section":"Tags","summary":"","title":"前端","type":"tags"},{"content":"","date":"3 November 2024","externalUrl":null,"permalink":"/categories/network/","section":"Categories","summary":"","title":"Network","type":"categories"},{"content":"","date":"3 November 2024","externalUrl":null,"permalink":"/tags/%E5%A4%8D%E4%B9%A0/","section":"Tags","summary":"","title":"复习","type":"tags"},{"content":"","date":"3 November 2024","externalUrl":null,"permalink":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","section":"Tags","summary":"","title":"计算机网络","type":"tags"},{"content":" 计算机网络总复习 # 第一章 概述 # 计算机网络：结点 node（计算器、交换机、路由器）+链路 link\n功能：数据通信、资源共享\nInternet TCP/IP ISP 局域网与广域网\n电路交换：突发式传输、适用低频\n传输时间少、有序到达、但要建立连接、不灵活、利用率低、无差错控制\n报文交换：无需连接、存储转发、利用率较高、差错控制、重传代价高\n无需连接、有序到达、但转发时延高\n分组交换：无需连接、存储转发、分组定长（拆分为多个分组）、重传代价低\n更加灵活，前面两种的折中、利用率非常高、传输时间少、支持差错控制、但需要携带很多额外控制信息、且不是有序到达\n网络分类 # WAN、MAN（城域网）、LAN、PAN（个域网）\n广播、点对点\n总线型（争用问题）、环形、星型（点对点）、网状（灵活但控制复杂线路成本高）\n公用网、专用网\n有线网、无线网\n性能指标 # bps、kbps、Mbps、Gbps、Tbps （按照\n$$10^3$$递增）\n速率（数据率、比特率、数据传输率）bps\n带宽：某信道允许通过的最高数据率 bps 或者表示 信号频带范围 Hz\n吞吐量：某个网络或节点、信道单位时间内的实际通过的数据量（实际的综合数据率）B\n时延：数据一端传送到另一端所需的时间\n发送时延/传输时延=$\\frac{数据长度(bit)}{发送速率(bit/s)}$：将数据推向信道所花费的时间（准备过程）\n传播时延=$\\frac{信道长度(m)}{电磁波在信道中的传播速度(m/s)}$：电磁波在信道中传播一定的距离所花费的时间（传播过程）\n处理时延：受网络负载、路由器性能等诸多因素影响（一般不考虑）\n排队时延：数据排队进入、发出路由器所花的时间\n总时延=发送时延+传播时延+处理时延+排队时延\n时延带宽积（bit）：单向传播时延 x 带宽\n往返时延 RTT：从发送方发送完数据，到发送方收到来自接收方的确认数据总共经历的时间\n信道利用率：某个信道有百分之多少的时间是有数据通过的。\n利用率低会浪费带宽、利用率太高会导致网络拥塞\n分层结构 # 每一个层次负责实现一个或多个功能，上一层实体通过“接口”，请求相邻下一层的“接口”，SAP（服务访问点）\n实体、对等实体、协议（水平）：通信规则集合、服务（垂直）：下层提供给上层的功能调用；\nOSI：7 层法律标准；TCP/IP 模型：事实\n五层模型（教学用）\nPDU：协议数据单元、SDU：服务数据单元、PCI：协议控制信息\n协议三要素：语法（格式）、语义、同步（时许）\nOSI 参考模型 任务 功能 应用层 实现特定网络应用 略 表示层 解决不同主机上信息不一致的问题 数据格式转换 会话层 管理进程间会话 会话管理 传输层 实现端到端通信 复用、分用、差错控制、流量控制、连接管理、可靠数据传输 网络层 将分组从源结点转发到目的结点 路由选择、分组转发、拥塞控制、网际互联、差错控制、流量控制、连接管理、可靠数据传输 数据链路层 确保相邻节点之间的链路逻辑上无差错 差错控制、流量控制 物理层 实现相邻节点比特之间的传输 需定义电路接口参数、信号的含义/电气特性等 区别 TCP/IP 模型，对上可以提供无连接不可靠的 IP 和 UDP 服务，而 OSI 只能提供有连接、可靠的服务\n第二章 物理层 # 任务：实现相邻节点之间比特（0 或 1）的传输\n通信原理 # 信源、信宿、信号、信道\n信源通过信道传输信号给信宿\n信号是数据的载体，数据是信息的实体\n信号有数字信号（离散，如电压正负）、模拟信号（连续，波形）\n每一个信号称作一个码元\n一个码元可以携带的比特数据位：一个周期内可能出现 K 种信号\n则\n$$ 1码元=\\log_2Kbit $$波特 Baud（率）：每秒传输几个码元(码元/秒)\n比特率：每秒传输几个比特（bit/s）\n通信原理中的带宽：某信道允许通过的信号频带范围 Hz（最大频率-最小频率）\n噪声：对信道产生干扰，影响信号的数据传输效率。\n电磁波、电压会受到环境电场、磁场的干扰\n奈氏准则 # 没有噪声（理想低通信道）的信道来说，它的极限波特率是 2W 波特，其中 W 是信道的频率带宽 Hz。\n$$ 极限比特率=2W\\log_2Kb/s $$K 为一个信号周期内可能出现的信号种类\n香农定律 # 有噪声、带宽有限的信道，则\n$$ 极限比特率=W\\log_2(1+\\frac{S}{N})(bit/s) $$W:信道的频率带宽（Hz）\n$\\frac{S}{N}：信噪比$\n$$ 信噪比=\\frac{S}{N}=\\frac{信号的功率（w）}{噪声的功率（w）} $$用单位记录：db（分贝）分贝转比值，假设分贝为 mdb：\n$$ m分贝=10\\log_{10} \\frac{S}{N} $$ 编码\u0026amp;解码、调制\u0026amp;解调 # 编码：二进制数据转换为数字信号\n解码：数字信号转换为二进制数据\n调制：二进制数据转换为模拟信号\n解调：模拟信号转换为二进制数据\n有线网络适配器：编码-解码器\n光猫：调制-解调器\n编码技术 # 不归零编码（NRZ）：低 0 高 1，中不变\n归零编码（RZ）：低 0 高 1，中归 0\n反向非归零编码（NRZI）：跳 0 不跳 1 看起点，中不变\n曼彻斯特编码：跳 0 反跳 1 看中间，中必变\n差分曼彻斯特编码；跳 0 不跳 1 看起点，中必变\n调制方法 # 基带信号：来自信源的数字信号（需要调制后才能在某些信道上传输，例如空气）\n调幅 AM 有信号就调成正弦波，信号为 0 就无幅度\n调频 FM 调制正弦波频率\n调相 PM 调制正弦波相位\nQAM（正交幅度调制）：AM+FM,即$1码元=\\log_2mnbit$\nQAM-16:16 种码元\n传输介质 # 导向型（有限）：双绞线、同轴电缆、光纤\n非导向型：无限传输介质\n单模光纤适合远距离传输（只传输一条光线）、多摸光纤适合近距离传输\n以太网对有限传输介质的命名规则\n速度（Mbps）+Base+介质信息\n介质信息：数字则为同轴电缆，5 代表最远传输距离 500m，F 代表光纤，T 代表双绞线\n电磁波：无线电波、微波（保密性差）\n波长越短、频率越高、带宽越高\n短波通信需要指向性强、长波不需要\n物理层接口特性 # 机械特性：接线器形状尺寸、引脚数目、排列、固定和锁定装置\n电气特性：接口电缆各条线上出现电压范围、传输速率、距离限制\n功能特性：某条线上出现某一电平的电压的含义\n过程特性（规程特性）；对于不同功能的各种可能事件的出现顺序\n物理层设备 # 传输距离越远，越有可能信号失真\n因此根据以太网规范限制传输距离长度\n可以通过中继器（半双工通信）延续信号，将电压整形为标准的电压\n集线器 Hub：多端口中继器。将一个端口收到的信号整形再生后，转发到其他所有端口\n不可同时发送数据，会导致冲突\nHub 的 N 个端口对应 N 个网段，各网段属于同一个“冲突域”\n合并 Hub，组成更大的冲突域（碰撞域 💥）\n集线器组成的网络拓扑结构是总线型的（逻辑上），物理上是星形\n连接的带宽共享 第三章 数据链路层 # 功能：封装成帧、透明传输、差错控制（（位错（检错编码、纠错编码）、帧错）、流量控制、可靠传输（通过滑动窗口））\n两种链路（信道）：点对点（广域网）、广播（局域网）\n结点：主机、路由器\n链路：两个结点之间物理通道\n数据链路：两个结点之间逻辑通道（链路+协议）\n帧：链路层协议数据单元\n加强物理层传输原始比特流的功能，将物理连接改造成逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路\n提供无确认无连接服务、有确认无连接服务、有确认面向连接服务\n封装成帧 # 为 IP 数据报添加首部和尾部：帧定界\n帧同步：接收方应该能区分帧的起始和终止\n数据部分\u0026lt;=MTU\n透明传输：对高层不可见。\n数据链路层的透明性在于能够无视传输的数据内容，但由于帧定界符会与内容混淆，所以需要实现某些规则\n实现透明传输 # 字符填充法（传输的帧）：SOH，EOT 的 8bit 数据\n在内容部分的控制信息前加入 ESC 转译义字符，在接收端去除所有转义字符\n零比特填充法：一连串比特连续发送，只要连续 5 个 1，就立刻填入一个 0，接收端发现 5 个 1 就把后面的 0 删除\n差错控制 # 有差错就要检错，实现了检错的编码\n差错的发生是由于噪声引起的：线路的电气特性导致全局性的随机噪声（热噪声）-\u0026gt;提高信噪比、外界短暂的特点原因的局部的冲击噪声（产生差错的主要原因）-\u0026gt;利用编码技术解决\n差错\n位错 0 变 1，1 变 0 帧错 丢失、重复、失序 不是所有链路都要差错检测！对于提供无确认无连接服务（通信质量好的链路）不需要\n有确认：就是有重传机制，有差错检测\n检错编码：奇偶校验码、循环冗余码 CRC\n纠错编码：海明码\n物理层与数据链路层编码不一样：一个是对于单个比特的传输同步、一个是一组比特的传输过程有无差错\n奇偶校验码 # n-1 位信息元+1 位校验元\n奇校验码：“1”个数为奇数\n偶校验码：“1”个数为偶数\nCRC 循环冗余码 # 代传数据除以生成多项式（2 进制编码），余数为 FCS 帧检验序列/冗余码，帧加上冗余码发送\n接收方接受数据除以生成多项式，余数为 0 则接受，余数不为 0 则 1 丢弃\n无差错接受：\n“凡是接收端数据链路层接受的帧，都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”\n并不是无比特差错的传输，因此不是可靠传输\n海明码 # 海明距离：码距，差错的个数\n码距为 n，可以检测 n-1 比特错\n确认冗余码/校验码位数 r,假设源信息有 m 位 $$ 海明不等式：2^r\u003e=m+r+1 $$ 确认校验码和数据的位置，校验码放在序号为$2^n$的位置（n 从 1 开始，在低位）（eg.1,2,4\u0026hellip;） 1 号校验码 xx1（最低位 1，负责 1，3，5，7 校验）\n2 号校验码 x1x（第二位 1，负责 2，3，6，7 校验）\n4 号校验码 1xx（第三位 1，负责 4，5，6，7）\n采用偶校验，确保每个校验码负责的对应位“1”个数为偶数，从而计算出海明码\n检错并纠错，收到的数据对每个校验码对应的负责位数校验检查“1”个数，查看哪一位出错（每一位异或，再结合起来）\n可靠传输与流量控制 # 流量控制：原因较高的发送速度与较低接受能力的不匹配\n（二层流量控制是点对点的，四层流量控制是端到端）\n手段：接收端发送给发送端一个窗口公告，控制发送速率，使接收方有足够的缓冲空间来接受每一个帧\n停止等待协议 发送帧-确认帧-发送帧-确认帧 低效\n发送窗口大小=1，接受窗口大小=1\n滑动窗口协议 发送窗口（发送的数据）、接受窗口确认发送帧、发送窗口前进\n后退 N 帧协议（GBN）\n发送窗口大小\u0026gt;1,接受窗口大小=1\n选择重传协议（SR）\n发送窗口大小\u0026gt;1,接受窗口大小\u0026gt;1\n可靠传输：发送什么、收到什么\n滑动传输解决的就是可靠传输与流量控制（收不下就不给确认+发送方自动重传 ARQ）\n停止-等待协议 # 除了镇内比特差错，还会出现丢包问题（帧、包、段）\n不考虑全双工，仅考虑半双工\n发送一个帧接受一个帧，计时器到期重传,⏰\u0026gt;平均 RTT，帧必须编号，重传则丢弃确认帧\nRTT(往返时延包括发送时延)吗？一般不包括，包括传播时延+排队时延+处理时延（接收方处理返回确认消息时间）\n上文是单向 RTT,双向 RTT 是双向传播时延\n$$ 信道利用率=\\frac{L}{CT} $$T:发送周期，从开始发送数据，到收到第一个确认帧为止（计算 T：发送时延+双向 RTT）\nL：T 内发送 L 比特数据\nC：发送方数据传输率\n$$ 信道吞吐率=信道利用率*发送方的发送速率 $$停止等待的信道利用率低，大部分时间发送方空闲\n后退 N 帧协议（GBN） # 解决停止-等待协议的信道利用率低问题，连续发送多个帧（流水线技术）\n必须增加序号范围（防止出错） 发送方需要缓存多个分组 滑动窗口：01234567\u0026hellip;发送的数据必须在窗口内\n接受窗口只有 1 格，收到 n 号帧就返回对 n 帧的确认帧（也可以累计确认，发送对前 n 帧的确认帧）\n已经发完的帧（不在窗口）、正在发送的帧，还能发送的帧（在窗口）、不能发送的帧（不在窗口）\n窗口已满则不能发送，但可以放在缓存\nGBN 累积确认：对前 n 号帧的全部接受\n超时计时器：后退 N 帧，若 N 帧的发送帧/确认帧没有收到，重传 N 帧以及后续未确认的帧，ACK 一直发送 ACK N-1\nGBN 总结：累积确认、接收方按序接受、ACK 最大按序到达的帧，提高信道利用率，但是重传的效率偏低\n选择重传协议（SR） # 解决 GBN 累积确认导致的批量重传带来的效率降低问题\n解决方法：设置单个确认、加大接受窗口、设置接受缓存、缓存乱序到达的帧\n发送，接受窗口：N\n发送窗口：发送完被确认的帧、已经发送但等待确认的、还能发送的\n接受窗口：希望收到但没收到的、收到且返回确认的（在缓存中）、等待接受的\n发送方：上层调用后 SR 发送帧或加入发送缓存、收到 ACK 移动窗口、超时时间后只重传一个帧\n接收方：对于接受窗口内的帧来者不拒，失序的帧将被缓存并返回给发送方该帧的确认帧（收到谁确认谁），直到所有帧均被收到为止，这时可以将一批帧按需交付给上层，然后向前移动窗口\n如果接收到窗口左边的帧，返回 ACK；\n超时重传；\n帧的标识位是有限的，会出现 n 号帧是新帧还是旧帧的无法确认，因此窗口不能过大\n$$ W_Tmax=W_Rmax=2^{(n-1)} $$n:帧编码个数\nW:窗口大小\nSR 总结：数据帧逐一确认、只重传出错帧、接收方有缓存\n信道划分\u0026amp;介质访问控制 # 点对点链路（PPP，广域网）、广播式链路（总线以太网、局域网：星型（逻辑总线型））\n介质访问控制：采取一定措施，使得两对节点之间的通信不会发生相互干扰：\n静态划分信道 频分多路复用 FDM、时分多路复用 TDM、波分开多路复用 WDM、码分多路复用 CDM\n动态分配信道 轮询访问：令牌传递协议\n随机访问介质：ALOHA，CSMA，CSMA/CD，CSMA/CA\n多路复用技术：多个信号组合在一条物理通道\n实质：广播信道组合为点对点信道\nFDM 每个用户同时分带宽的各个频段\nTDM 带宽一致，每个用户交替使用信道（轮流、周期性）\nSTDM（统计时分复用） 发送到集中器的缓存，按需动态分配\nWDM 本质：光波的频分复用\nCDM 每个比特指定固定的 m 位芯片序列\n发送 1 时候发送对应芯片序列、发送 0 时候发送芯片序列反码\n发送的时候两个芯片序列互相正交，规格化内积为 0 $$ S·T=\\frac{1}{m}\\sum_{i=1}^{m}S_iT_i=0 $$ 两个向量到了公共信道上，线性相加，S-T 数据分离：合并的数据和原站点规格化内积，得到发送的数据，1 代表 1，-1 代表 0 $$ S·(S-T)=1 $$$$ T·(S-T)=-1 $$以下为动态划分信道\n特点：信道并非在用户通信时固定分配给用户\n随机访问：所有用户可随机发送信息，发送信息时占据全部带宽。（不协调）\nALOHA # 每个站点不监听信道，随机重发 成功率低\n时隙 ALOHA # 时间片同步接入信道。发生冲突则等待到下一个时间片再重发\nCSMA（载波监听多路访问协议） # 先听再说！\nCS：发送数据前检测总线电压摆动值（检测碰撞）\nMA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上\n坚持 CSMA：监听信道忙，则监听直到有空闲直接传输\n如果有冲突等待一个时间再监听\n非坚持 CSMA：忙则不继续监听，等待一个随机时间再监听\np-坚持 CSMA：对于信道空闲的时候，以 p 概率进行直接传输；1-p 概率等到下一个时间槽再传输\n忙则持续监听直到信道空闲，再以 p 概率发送\n若冲突则等待下一个时间槽再监听并重复以上过程\nCSMA/CD # 先听再说，边听边说\nCS：载波监听\nMA：多点接入 总线型\nCD：碰撞检测\n监测到数据错误（碰撞 💥），立刻停发数据\n单程端到端传播时延：$\\tau$\nB 监测到碰撞时间（A 发送的数据到达）：$t=\\tau$\n假设 B 发送的时间为$t=\\tau-\\delta$\n则 A 检测到碰撞时间$t=2\\tau-\\delta$\n因此，最迟需要$t=2\\tau$时间才能监测到自己发送的数据有没有和其他数据产生碰撞（两倍总线端到端时延，一个争用期）\n重传时间：截断二进制指数规避算法\n退避时间=基本争用期$2\\tau$ 定义 k 为重传次数（小于 10），再大就一直保持 10 从$[0,1,2^k-1]$中随机取出一个数 r $$ 重传退避时间=r倍的基本退避时间=2r\\tau $$ 重传 16 次还未成功，则抛弃此帧并向网络层报告（网络拥挤） 帧太短会再发送完毕之前检测不到碰撞，因此需要规定最小帧长：帧的传输时延至少要两倍于信号在总线上的传播时延\n$$ \\frac{帧长(bit)}{数据传输速率}\\geq2\\tau $$因此\n$$ 最小帧长=总线传播时延\\times数据传输速率\\times2=2\\tau\\times数据传输速率 $$以太网规定最小帧长 64Bytes\nCSMA/CA # 应用：无线局域网\n空闲发送 RTS（request to send），收到接收端的 CTS（clear to send）,开始预约信道\n接收端收到帧后用 CRC 检验，正确响应 ACK 帧，收到则继续发送，否则进行二进制指数退避算法重传\n局域网基本概念和体系结构 # 多采用分布式控制和广播式通信\n星形拓扑、总线型拓扑 ✅（以太网：逻辑总线）、环形拓扑、树形拓扑\nIEEE 802 标准\nIEEE 802.3 以太网介质访问控制协议（CSMA/CD）及物理层技术规范\nIEEE 802.5 令牌环网（单点故障）\nIEEE 802.8 光纤技术环网\nIEEE 802.11 无线局域网(WLAN)\nLLC 子层、MAC 子层\n以太网 # Ethernet 使用 CSMA\\CD\n满足速率要求：10Mb/s~10Gb/s\nDIX Ethernet v2 或 IEEE 802.3\n无连接、不可靠的服务\n10BASE-T 无屏蔽双绞线 10Mb/s 100m 曼彻斯特编码\n局域网通信：适配器（网卡）\nMAC 地址 48bit 前 24bit 代表厂家（IEEE 规定）后 24 位厂家自定\n物理层：前导码+MAC 帧\nMAC 层：6B 目的地址（全 F 为广播）、6B 源地址、类型（上层协议）、数据（IP 数据报）46（最小帧长 64B-6-6-2-4）-1500B（MTU）、FCS（帧检验序列）\n高速以太网 # 100BASE-T 双绞线 100Mb/s 星形 可以全双工无冲突\n吉比特以太网 光纤或双绞线 1Gb/s 可以全双工无冲突\n10 吉比特 光纤 10Gb/s 只支持全双工 无冲突\nIEEE 802.11 无线局域网 # 2B 2B 6B 6B 6B 2B 6B 帧控制 生存周期 ID RA 接收端 TA 发送端 DA 目的地址 序列控制 SA 源地址 AP 无线接入点：基站\n发送端和接收端：两个基站的 MAC 地址\nBSS：基本服务集，由一个 AP（Access Point 接入点）和多个无线客户端\nESS：扩展服务集，多个 BSS 互联\n基站之间有限通信\n漫游：自动选择最近的 AP\nVLAN # 流量隔离（广播帧的泛洪） 用户管理 降低路由成本 将局域网内的设备划分成与物理位置无关的逻辑组，每个 VLAN 是单独的广播域\n交换机转发表 MAC 地址：端口 映射\nVLAN 表 VLAN id：端口 or MAC 地址 贴标签：在类型前加入 4B VLAN 标记（后 12 位 VID，0-4095）\nWAN # 广域网：分组交换技术，强调资源共享\nPPP：全双工链路，无流量控制和纠错，帧定界符，透明传输，多种网络层协议、多种类型链路、差错检测、检测连接状态、最大传输单元、网络层地址协商、数据压缩协商\nLCP（链路控制）身份验证、NCP（网络控制）\n定界符 7E，转义字符 7D，地址字段 A FF\nF、A、C、协议、信息部分、FCS、F\n扩展以太网 # 集线器：具有冲突域\n网桥：转发与过滤 MAC 帧，能够区分网段\n交换机：多端口网桥\n网桥转发表自学习：地址和端口，没有就写入广播，有就转发，每隔一段时间清空\n交换机自学习算法，与网桥一样\n冲突域：每个结点都能收到所有被发送的帧\n广播域：网络中能接收到一个结点发出广播帧的所有设备的集合\n（物理层）中继器、集线器：不能隔离冲突域和广播域\n（链路层）网桥、交换机：能隔离冲突域、不能隔离广播域\n（网络层）路由器：都能\n第四章 网络层 # sdn：控制平面\nIP 数据报：版本、首部长度 5-4B、区分服务、总长度1B、标识、标志、片偏移、TTL、协议（数据部分）、首部检验和、源地址和目标地址：32 位、可选字段 0 ～ 40B、填充：全 0，把首部补成 4B 整数倍\nIP 数据报分片 # 从 0 开始\n不能超过以太网的 MTU 1500Bytes，超过则 ip 分片\n标识：标志同一数据报的分片\n标志：最低两位有意义，DF（不许分片）1 禁止，0 允许，MF（更多分片），1 还有分片，0 代表没有分片\n片偏移8B：某片在原分组中的相对位置（字节序除以 8Bytes）\nIPv4 # 在哪个网络？\n在网络下的哪个主机？\nIP 编址：\n分类 IP 地址：\u0026lt;网络号\u0026gt;\u0026lt;主机号\u0026gt;32 位/4B 每 1B 点分十进制 A 类 1 ～ 126 网络号 1B 主机号 3B 0\n最大网络数 $2^7-2$ 1 126 最大主机数 $2^{24}-2$\nB 类 128 ～ 191 网络号 2B 主机号 2B 10 最大网络数 $2^14-1$ 128 191 最大主机数 $2^{16}-2$\nC 类 192 ～ 223 网络号 3B 主机号 1B 110 最大网络数 $2^8-2$ 192 223 最大主机数 $2^8-2$\nD 类 224 ～ 239 多播地址 1110\nE 类 240 ～ 255 保留 1111\n0.0.0.0 只可以作为源地址，本网络范围内表示主机，路由表表示默认路由\n网络号全 0，主机号特定值 只能源地址，表示本网范围内某个主机\n255.255.255.255（全 1）只能作为目的地址，广播地址，路由器不转发\n网络号特定值，主机号全 0 不可作为地址，表示一个网络\n网络号 127，主机号任何数（不全为 0 或者 1），可以作为目的地址和源地址 环回地址 本地软件环回测试 （软件测试）\n私有（内部）IP 地址 # A 类\n10.0.0.0~10.255.255.255 网段个数 1\nB 类\n172.16.0.0 ～ 172.31.255.255 网段个数 16\nC 类\n192.168.0.0 ～ 192.168.255.255 网段个数 256\n网络地址转换 NAT # 目的：私有 ip 转换为公有 ip\nNAT 路由器：NAT 转换表 WAN 端对应 LAN 端的 ip 和端口号\n子网划分和子网掩码 # 将主机号划分为：子网号、主机号\n主机号不能全 0（网络号）和全 1（广播）\n子网掩码与 IP 地址逐位相与，得到子网网络地址\n直接交付（子网掩码相与查看网络号是否匹配）、间接交付（特定主机路由、路由表路径检测、默认路由、丢弃报告出错）\nCIDR 无分类编址 # IP 地址后加上/，写上网络前缀的位数\nCIDR 子网掩码：网络前缀多少就前多少个 1\n超网 # 多个子网聚合成一个较大的子网，叫做构成超网\n取网络号前 n 位的交集，合并成一个更大的网络\n最长前缀匹配 # 使用 CIDR，查找路由表可能得到多个匹配结果，应选择具有最长网络前缀的路由\nARP 协议 # 知道源 ip 地址的 MAC 地址（封装的时候填入），如何知道目的 ip 地址的 MAC 地址？\n查询本地 ARP 高速缓存（ip：MAC），没有则使用 ARP 协议\n主机发送 ARP 广播帧，目的 MAC 地址全 F（1）\n有对应 MAC 地址的主机响应单播 ARP 响应地址\n“下一跳”：到下一个具有 ip 地址（MAC 地址）的设备\n10-20min 更新一次 ARP 缓存\n主机要找本网内：ARP 找到本网主机 MAC；找外网：ARP 找到本网路由器 MAC\n路由器要找本网内：ARP 找到本网主机 MAC；找外网：ARP 找到另一个路由器 MAC\nDHCP # 静态配置：ip+子网掩码+默认网关\n动态 ip 地址分配：DHCP 服务器（应用层，基于 udp），地址重用\n租用期：限时\n主机广播 DHCP 发现报文（找服务器）、服务器广播 DHCP 提供报文（预分配 ip）、主机发送 DHCP 请求报文（请求分配）、服务器广播 DHCP 确认报文（正式分配 ip）\nICMP # 支持主机或路由器的差错（异常）报告\n网络探询\n五种差错报告报文：终点不可达、拥塞丢弃、超时、首部出错、重定向（改变路由：不是最好的路由）\nICMP 前 8Bytes+IP 首部+数据字段前 8Bytes=ICMP 差错报告报文\n装入 IP 字段（加 IP 首部）\n组播、特殊地址、第二个及以后分片不发送 ICMP 差错报告\nICMP 询问报文\n回送请求和回答报文 收到询问主机必须给源主机或路由器发送 ICMP 回送回答报文 ping 时间戳请求和回答报文 回答当前时间日期，进行时钟同步和时间测量 应用：PING、Traceroute（跟踪源点到达终点的路径）\nIPV6 # IPv4 已经耗尽，CIDR NAT 治标不治本\u0026hellip;\n基本首部、有效载荷\n基本首部：版本、优先级、流标签（从一个源到一个目的）、有效载荷长度、下一个首部、跳数限制、源地址（128bit）、目的地址（128bit）\n删除校验和字段 删除可选字段，加入扩展首部 即插即用（自动配置），不需 DHCP 首部长度是 8B 整数倍,IPv4 是 4B 整数倍 IPv6 只能在主机出处分片，IPv4 可以在路由器和主机分片 ICMPv6：附加报文分组过大 支持资源预分配 取消协议字段，改成下一个首部字段 取消总长度字段，该用有效载荷长度字段 取消服务类型字段 表示：冒号十六进制记法\n单薄、多播、任播\n兼容性：双栈协议、隧道技术\n回顾：路由选择协议\n内部网关协议 RIP、OSPF 外部网关协议 BGP RIP # 分布式、基于距离向量的路由选择 简单\n每个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录（最短跳数）\n目的网络 距离 下一跳路由器 Net2 1 直接交付 Net1 2 R1 Net4 2 R3 距离=跳数=从源到目的经过路由器个数\nRIP 仅允许一条路由包含 15 个路由器，距离为 16 代表网络不可达\n只能和相邻的路由器交换信息 路由器交换的信息是自己的路由表 30 秒交换一次路由表 路由器初始只知道距离为 1 的下一跳，接着和相邻路由器交换并更新路由信息\n经过若干次更新，达到收敛\n修改相邻路由器 x 发来 RIP 报文所有表项，下一跳改为 x，距离+1 对修改后 RIP 报文每一项： 路由表没有 Net，则把该项目填入表\n有 Net，则查看下一跳：\n下一跳是 x，则用收到的项目更新路由表\n不是 x，则原来距离比 x 远则更新，否则不处理\n180s 内没收到 x 的更新路由表，则把 x 标记为不可达，即距离设置为 16 返回 RIP 报文在 UDP 数据报中，也就是说 RIP 是应用层协议\n一个 RIP 最多 20 个路由信息\n缺点：会造成传输错误信息的循环，好消息快收敛，坏消息慢收敛\nOSPF # 开放最短路径优先 Dijkstra 最短路径算法 SPF\n分布式链路状态协议\n使用泛洪法向自治系统内所有路由器发送信息，而每一个相邻路由器又将此信息发送给所有相邻路由器 广播 发送信息是相邻路由器的路由状态 只有当链路状态发生变化时，路由器才向所有路由器泛洪 链路状态路由算法\n使用 Dijkstra 算法算出最优选择\nOSPF 将自治系统划分为区域，适合大规模系统\n在 IP 数据报内发送，是网络层协议\n30min 更新一次，收敛速度很快，坏消息也很快\nBGP # AS 自治系统间交换信息，通过 BGP 发言人（边界路由器）\n发生变化才更新\nBGP 交换的信息是到达某个网络所要经过的一系列 AS\n交换路径向量，沿某一路径$(AS_1,AS_2)$可以到达网络$N5,N6,N7$\nBGP 报文放入 TCP 报文的数据段，是应用层协议\nBGP 支持 CIDR，开始运行交换整个路由表，后续之交换变化的信息\nBGP-4 连接\nOPEN 报文 UPDATE 报文 KEEPALIVE 报文：周期性确认连通性 NOTIFACTION 报文：可以关闭连接 总结：RIP 内部网关，使用广播 UDP，跳数最少，距离-向量；\nOSPF 是内部网关，使用 IP，代价最低，泛洪，链路状态；\nBGP 是外部网关，使用 TCP，较好，路径-向量；\nIP 组播 # 单播：点对点，源-目的\n广播：点对多点，全部端口\n组播（多播）：只给相同需求的主机发送，点对多点，最后一步路由器才会复制\nIP 组播地址：部分D 类地址：224.0.0.0~239.255.255.255，一个 D 类地址表示一个组播组。只能用作分组的目标地址，最大努力交付 UDP，不产生 ICMP\n组播 MAC 地址 01-00-5E 开头，后面将 IP 地址后 23 位映射到以太网地址\nIGMP # 让局域网上的组播路由器知道网内是否有主机参加或退出了某个组播组\n使用 IP 数据包\n发送 IGMP 报文给某个路由器，声明想要加入某个组播组 利用协议把关系发给其他组播路由器 周期性探询本地路由器是否是组播组的成员，经过几次探寻未响应就不再把成员关系发给其他的组播路由器 组播路由选择协议 # 组播转发树\n移动 IP # 到达不同物理地点，保持 ip 地址不变\n网络层设备 # 路由器：多输入/输出端口的专用计算器，任务是转发分组\n根据路由选择协议构造路由表、更新维护路由表、根据转发表对分组进行转发\n输入端口：接受分组、直到网络层分组排队：查表和转发（产生时延）\n输出端口： 设置缓冲队列，排队输出\n分组丢失原因：输入队列或输出队列缓冲区因为排队溢出\n根据路由表（默认路由全 0）来得出转发表\n第五章 传输层 # 概述 # 端系统层次：主机独有\n为应用层提供通信服务\n提供进程与进程间的逻辑通信 复用和分用 报文进行差错检测 TCP、UDP\n面向连接、可靠和无连接、不可靠\n复用：应用层所有的应用进程都可以通过传输层再传输到网络层\n分用：传输层从网络层收到数据后交付给对应应用进程\n端口：传输层 SAP（服务访问点），本地意义\n端口号\n服务端：熟知端口号 0 ～ 1023，登记端口号 1024 ～ 49151 客户端：49152 ～ 65536 动态选择 FTP：21\nTELNET：23\nSMTP：25\nDNS：53\nTFTP：69\nHTTP：80\nSNMP：161\n套接字 Socket=（ip，port）\nUDP # 复用分用、差错检测\n无连接、最大努力交付\n面向报文，长度不改变，适合一次性少量数据\n首部 8B，数据字段可以为 0\n首部：源端口号 2B，目的端口号 2B，UDP 长度 2B，UDP 检验和 2B\n找不到目的端口号丢弃报文，发送 ICMP“端口不可达”差错报告报文\nUDP 校验 # 伪首部：模仿 ip 首部，只有计算校验和时出现\nTCP # 虚连接，点对点连接（进程对进程）\n可靠有序，不丢不重\n全双工通信：发送缓存（准备发送的数据\u0026amp;已发送但未收到的数据）；接受缓存（按序到达但尚未被应用程序读取的数据\u0026amp;不按序到达的数据）\n面向字节流：传输层将应用层报文视作连续字节流\n首部格式 # 20B 首部，源端口目的端口各 2B，总共 4B，\n序号：字节流的第一个字节的顺序编号\n确认号：期望收到对方下一个报文段的第一个数据字节的序号，若确认号位 N，则证明到 N-1 点所有数据已正确收到\n数据偏移（首部长度）：TCP 报文段的数据起始处距离 TCP 报文段段起始处有多远，4B 一个单位\n紧急位 URG：为 1 时在缓存区优先发送\n确认位 ACK：为 1 时确认位有效\n推送位 PSH：为 1 时接收方尽快交付接受应用进程\n复位 RST：为 1 时需要释放 TCP 连接\n同步位 SYN：表明是连接请求/连接接受报文\n终止位 FIN：为 1 时表明发送方数据已发完，要求释放连接\n窗口：自己的接收窗口，可以容纳的字节流，对方应根据窗口设置发送窗口（流量控制）\n检验和：检验首部+数据，检验时加上伪首部 12B，第四个字段为 6\n紧急指针：URG=1 时有意义，指出紧急数据的字节数\n选项：可选，最大报文段长度 MSS、窗口扩大、时间戳、选择确认\u0026hellip;\nTCP 连接管理 # 客户-服务器方式（C/S）\n三次握手-四次挥手**\nC：连接请求报文段，无数据\nSYN=1，seq=x（随机）序号 S：为 TCP 连接分配缓存和变量，返回确认报文段，无数据\nSYN=1，ACK=1，ack=x+1（想要收到的下一个序号），seq=y（随机） C：确认的确认，可以携带报文数据，分配 TCP 连接缓存和变量\nSYN=0（同步已经完成了），ACK=1，seq=x+1，ack=y+1（想要收到下一个序号） SYNFLOOD 泛洪攻击\n攻击者发送大量第一个握手数据包 SYN，服务器返回 ACK 确认后，攻击者不进行确认。TCP 连接处于挂起状态，浪费服务器资源导致崩溃 连接释放\nC：发送连接释放报文段，停止发送数据\nFIN=1，seq=u S：服务器送回确认报文段\u0026ndash;半关闭状态\nACK=1，seq=v，ack=u+1 S：服务器发送完毕所有数据，发出连接释放报文段\nFIN=1，ACK=1，seq=w，ack=u+1 C：客户端送回一个确认报文段，在等待时间等待计时器设置的 2MSL（最长报文段寿命）后，连接彻底关闭\nACK=1，seq=u+1，ack=w+1 可靠传输 # 可靠：保证接收方进程从缓冲区读出的字节流与接收方一致\n确认机制 # 直到接收方完整接收到报文段，才把缓存区中的发送报文段删除（确认报文段）\n累积确认：只确认第一个丢失字节开始的报文段\n重传：超时重传\nRTTs（加权平均往返时间）：自适应算法计算的时间\n冗余 ACK（确认）：快速重传，每当比期望序号大的失序报文段到达时、发送一个冗余 ACK，指明下一个期待字节的序号\n可靠传输在数据链路层已经讲过\n流量控制 # 发送方的速率放慢\nTCP 利用滑动窗口机制实现流量控制\n接收方根据接受缓存大小，动态调整发送方发送窗口大小、即接受窗口 rwnd（接收方设置确认报文段的窗口字段来将 rwnd 通知给发送方），发送方的发送窗口取接受窗口 rwnd 和拥塞窗口 cwnd 的最小值\ne.g. ACK=1，ack=201(期望收到下一个是 201 开头的报文段)，rwnd=300（允许发送 201-500B 的窗口）\n然后发送窗口往前移动，发两次 100B 的报文段（最大报文段），然后发送窗口满了，进入等待状态，直到接收方传来新的确认以及 rwnd 的大小，改变窗口大小并前进，重复以上过程\n如果窗口为 0，启动一个持续计时器，到期后发送0 窗口探测报文段，接收方给出现在的窗口值，若为 0 则继续等待开启计时器\n拥塞控制 # 条件：对资源需求的$总和\\ge可用资源$\n网络吞吐量随输入负荷增大而下降，因此要协调防止过多的数据注入到网络中\n与流量控制区别：流量控制是点对点一对一对，拥塞控制是多对一的，有很多主机占据一条带宽\n四种算法 # 慢开始、拥塞避免、快重传、快恢复\n假设：\n数据单方向传送，另一个方向只传送确认 接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度 $$ 发送窗口=Min(接受窗口rwnd,拥塞窗口cwnd) $$接受窗口：接收方根据接受缓存设置的值，并告诉发送方，反映接收方容量\n拥塞窗口：发送方根据自己估算的网络拥塞程度设置的窗口值，反映网络当前容量\n慢开始和拥塞避免 开始 cwnd=1，“指数增长”，直到 ssthresh 门限初始值 16，然后开始拥塞避免，”加法增大“，直到网络拥塞，记录下当前的 cwnd 拥塞窗口，设置新的 ssthresh=$\\frac{cwnd}{2}$,设置 cwnd=1，重复慢开始流程。\n快重传和快恢复 慢开始、拥塞避免“加法增大”、收到 3 个重复的 ACK（说明冗余了），立刻执行快重传算法（比超时计时器快，节省时间），快恢复“乘法减小”，降到新的门限制为$\\frac{cwnd}{2}$，然后继续加法增大\u0026hellip;\n第六章 应用层 # 为应用程序的通信提供服务\n定义：\n应用进程交换的报文类型，请求还是响应？ 各种报文类型的语法，如报文中的各个字段机器详细描述 字段的语义、即包含在字段中的信息的含义 进程何时、如何发送报文，以及对报文进行的响应的规则 文件传输、访问和管理、电子邮件、虚拟终端、查询服务和远程作业登陆\nFTP、SMTP、POP3、HTTP、DNS\nC/S 模型、P2P 模型\nDNS # 域名解析为 ip 地址\n根域名 .\n顶级域名\n国家 cn,us,uk 通用顶级域名 com,net,org,gov,int,aero,museum,travel 基础结构域名/反向域名 arpa（ip 反 DNS 到域名） 二级域名\n类别域名 ac,com,edu,gov,mil,net,org 行政区域名 bj,js 自定义域名 三级域名\n四级域名\n**域名树 🌲**表示\nDNS 服务器：层次划分\n特殊：本地域名服务器，优先发给本地 DNS Server\n如果本地 DNS 服务器没有，查询根域名服务器 13 个 但有更多分服务器\n两种方式：递归查询和迭代查询\n递归查询：根域名服务器知道下一级顶级域名服务器的位置，然后是权限域名服务器（只能负责一个区：每一个区是某个域名及其子域名的管理，自定义），如果还不能完成请求，那就再给出其他的权限域名服务器地址进行查询，直到查询成功逐层返回，直到给本地域名服务器\n迭代查询：由本地域名服务器一个个询问（多用）\nFTP # 文件上传、下载\nC/S 协议，TCP 实现可靠传输\n1 个主进程，多个从属进程\n20 端口\n文本模式：ASCII\n二进制模式：Binary\n电子邮件 # SMTP 客户、邮件服务器\n邮件服务器间 POP3，IMAP\n端口 25\nC/S\nWWW 和 HTTP # World Wide Web，大规模联机的信息储藏空间\n使用统一资源定位符 URL 标识唯一资源 HTML（超文本标记语言 HyperText Markdown Language）\nURL 格式：\u0026lt;协议名\u0026gt;://\u0026lt;主机\u0026gt;:\u0026lt;端口\u0026gt;/\u0026lt;路径\u0026gt;\n通过超链接获取资源，这些资源通过超文本传输协议 HTTP（HyperText Transfer Protocol）\nC（Browser 浏览器）/S（Server）\n一个服务器监听 TCP 端口 80\n浏览器分析 URL，向 DNS 请求解析为 IP 地址，浏览器与服务器建立 TCP 连接，发送 HTTP 请求报文，获得 HTTP 响应报文，获取资源，浏览器解析并展示，释放 TCP 连接\nHTTP 无状态、无连接（虽然有 TCP 连接） Cookie 本地存储历史记录\n连接方式：\n非持久连接 TCP 连接三次握手 接下来发送和接受 HTTP 报文，关闭 TCP 连接 持久连接 多次请求报文的时候不关闭 TCP 连接，分为流水线式（等待两个 RTT）和流水线式（一个 RTT） HTTP 报文结构 # 面向文本，每一个字段都是ASCII 码\n请求报文：方法 URL 版本 回车行 CRLF\n首部字段名 值 CRLF\n\u0026hellip;CRLF\n主体\n响应报文：版本（HTTP/1.1 HTTP/2 HTTP/3） 状态码 短语 CRLF （状态行）\n首部字段名 值 CRLF\n\u0026hellip;CRLF\n主体\n响应状态码：\n1xx 表示通知信息，请求收到或正在处理 2xx 表示成功，接受 3xx 表示重定向，如需完成请求需要进一步行动 4xx 表示客户出错，如请求中语法错误或不能完成 5xx 表示服务器出错，如服务器失效或无法完成请求 ","date":"3 November 2024","externalUrl":null,"permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/","section":"Posts","summary":"\u003ch1 class=\"relative group\"\u003e计算机网络总复习 \n    \u003cdiv id=\"计算机网络总复习\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e6%80%bb%e5%a4%8d%e4%b9%a0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\n\u003ch2 class=\"relative group\"\u003e第一章 概述 \n    \u003cdiv id=\"第一章-概述\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e7%ac%ac%e4%b8%80%e7%ab%a0-%e6%a6%82%e8%bf%b0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e计算机网络：结点 node（计算器、交换机、路由器）+链路 link\u003c/p\u003e","title":"计算机网络考试复习（详细版）","type":"posts"},{"content":"","date":"3 November 2024","externalUrl":null,"permalink":"/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/","section":"Tags","summary":"","title":"网络协议","type":"tags"},{"content":" 🛜 五层体系结构协议复习 # 首先我们需要了解为什么计算机网络要学习五层结构模型（TCP/IP 模型），因为这更简化，便于我们了解实际网络协议，并且更贴近现实的网络组成。\n而七层模型（OSI）则是由国际标准化组织 ISO制定的，为网络设计提供了框架，这其实是一个概念模型，虽然在实际上不常用，但为网络设计提供了参考。\n层 # 让我们来看一下五层和七层有哪些层次，七层实际上在五层基础上加了两层：\n物理层 Physical\n数据链路层 Data Link\n网络层 Network\n传输层 Transport\n会话层 Session 表示层 Presentation 应用层 Application\n对于学过计网的人来说，夹在第四和第五之间的两个层或许不太熟悉，我们来介绍一下。会话层负责建立、管理和终止应用程序之间的会话。可见主要是 Socket 的建立和关闭操作。因为传输层只负责端到端的可靠传输，而给上层提供接口靠的是 Session 层；再看看表示层，它负责处理数据表示形式，包括加密、解密、压缩和格式化，确保不同系统之间的数据能正确解释，例如 SSL/TLS 加密、JPEG 格式转换。可见表示层更切近应用层的具体应用。\n让我们回归正题，复习一下五层结构的各类协议/技术。\n物理层 # 实现设备之间的比特传输，定义物理连接（相邻的主机到主机）的标准。\nEthernet（以太网）：有限网络的电气和信号标准。 IEEE 802.11（Wi-Fi）：定义无线局域网的通信方式。 光纤：高速骨干网传输。 Bluetooth（蓝牙）：短距离无线通信协议。 数据链路层 # 实现同一局域网中的节点（主机和主机）间通信，负责帧的封装、差错检测和流量控制。\nEthernet（以太网）：最广泛的局域网数据传输协议，实现以太帧（Frame）格式的定义和介质访问控制。\nPPP（Point-to-Point Protocal）：提供点到点的链路传输，如电话拨号。（也有特殊格式的帧）\nHDLC（High-Level Data Link Control）：面向比特的链路控制协议，用来实现时钟同步。（也有特殊格式的帧）\nARP（Address Resolution Protocol）：将 IP 地址解析为 MAC 地址，用于局域网通信，实现从三层到二层转换的方式。\nVLAN（Virtual LAN）技术：虚拟局域网，使得相同交换机下的主机可以分配到不同子网。\n网络层 # 实现不同网络（局域网）之间的数据传输，负责路径选择和路由转发，实现 Internet 上主机到主机的连接。\nIP（Internet Protocol）：网络层核心，定义数据包的封装与路由，它的任务只是根据数据包标头的 ip 地址，将数据包从源主机传送到目标主机。 IPv4:广泛使用的协议，32 位 IP 地址，使用 ARP 协议地址解析。 IPv6：128 位地址，采用 NDP 协议。 ICMP（Internet Control Message Protocol）：用于传递网络层错误消息和状态消息，广为流传的 ping 指令。它是依靠 IP 协议的协议，IP 数据包中有它。利用 TTL 将路由诊断信息返回到源。 IGMP（Internel Group Management Protocol）：实现 IP 多播。 路由协议 # 距离向量路由协议 DVRP # 距离向量路由协议（DVRP）也被称为“按跳数计算的路由算法”，其原理是：每个节点都维护到达目的节点所需的距离，每次更新将本节点到所有其他节点的距离向量发送给相邻节点，相邻节点再将其发给相邻节点……直到所有节点的距离向量被更新。最终每个节点都得到了到达目的节点的最短距离。\n常见的距离向量路由协议有\nRIP（Routing Information Protocol） IGRP（Interior Gateway Routing Protocol） 链路状态路由协议 LSRP # 链路状态路由协议（LSRP）也被称为“基于状态的路由算法”，其原理是每个节点都把自己的链路状态信息发给相邻节点，相邻节点保存下来并传递给其它相邻节点。当所有节点都交换完成链路状态信息之后，每个节点通过计算最短路径算法得到网络的最短路径。\n常见的链路状态路由协议有\nOSPF（Open Shortest Path First） IS-IS（Intermediate System to Intermediate System） 静态路由协议 # 在静态路由协议中，网络管理员手动配置路由表，然后路由器依据配置的路由表进行数据包的转发。\n静态路由协议的缺点是不灵活，不能及时响应网络拓扑结构的变化。\n动态路由协议 # 动态路由协议可以根据网络拓扑结构的变化自动调整路由表，路由表的计算是通过运行路由协议来完成的。动态路由协议虽然比静态路由协议更复杂，但是具有灵活、自适应、可靠的优点。\n常见的动态路由协议有\nBGP OSPF IS-IS RIP IGRP EIGRP OSPFv3 单播、多播、组播路由协议 # 单播路由协议是指进行单播转发的路由协议。多播路由协议是指进行多播转发的路由协议。组播路由协议是一种组播数据包传输的路由协议，与多播路由协议类似。\n内部网关协议和外部网关协议 # 内部网关协议（IGP）是指在一个企业或组织内部部署、用于内部路由器之间通信的协议，如 RIP、IGRP、EIGRP、OSPF 和 IS-IS 等。外部网关协议（EGP）是指在不同的自治系统之间进行路由选择的协议，如 BGP,各大 ISP 进行连接使用的是 BSP 协议（使用 TCP 连接）。\n工作原理 # 路由协议的工作原理可以分为四个步骤：\n邻居发现 路由表建立 路由表维护 路由表选择 在选择适合特定网络环境的路由协议时，需要综合考虑网络规模、复杂性、性能需求和管理能力。通常，大型企业网络和互联网使用链路状态协议（如 OSPF 和 IS-IS），而小型网络可能会选择距离向量协议（如 RIP）。同时，BGP 在连接自治系统之间的路由选择方面具有广泛的应用。\n以上路由协议部分内容均为这篇华为云社区文章的原创内容，本博客仅作为个人学习使用，无抄袭意图，了解详情请点击超链接进入此博客观看。\n传输层 # 提供端到端（port）的数据传输服务，确保数据包按顺序、无误地传输到目的主机。\nTCP（Transmission Control Protocol）：面向连接、可靠的协议，提供可靠的数据传输和流量控制。适用于需要保证数据完整性的应用，如 HTTP、FTP。 UDP（User Datagram Protocol）：无连接协议，不保证数据的可靠传输，但传输速度快。适用于实时应用，如视频流、在线游戏，DNS 解析也用 UDP。 SCTP（Stream Control Transmission Protocol）：同时支持多流传输的协议，适用于 VoIP 等应用。 TCP 与 UDP 的区别之一是重传丢失的数据。在 TCP 协议中，每个数据包都被赋予一个唯一的序列号。数据包发送者仔细跟踪发送了哪些数据包。作为响应，接收系统发出一个 ACK 数据包（代表“确认”），其中包含确认收到的数据包的序列号。如果序列号不匹配或丢失，发送机器将重新发送数据包。这个过程会持续下去，直到匹配的 ACK 确认传输成功。\n第二大区别是通过三向握手建立持久化连接。在 TCP 中，三向握手是一种通信机制，以确保所有数据的发送和正确接收。简而言之，这发生在三个部分：\n初始化(SYN)：SYN 是想要建立通信的设备发出的初始数据包。该数据包包含同步标志(SYN)和接收者的 IP 地址。 **确认启动(SYN-ACK)：**接下来，接收者发回 SYN-ACK 数据包，假设它已准备好并愿意进行通信。 **最终确认(ACK)：**一旦发送方收到 SYN-ACK，就会发送最终 ACK 以确认有效连接。 TCP 面向连接是依赖于它的错误检测和流量控制等其他功能*（在后文）*，这些特性成为 TCP 面向连接的本质的支柱。\nTCP 错误检测和流量控制简述 # 应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 TCP 段（TCP Segment）（IP 是超过 MTU 1500 Bytes，即以太网帧的载荷后分片，⚠️ 注意分片标识、偏移量、MF 更多分片标识、DF 禁止分片标识这些概念）。TCP 段对应标识有 Seq 序列号（如何组装在一起）、确认号（希望接受的下一个字节的序号，累积确认机制标识以及成功接受的数据，未确认的字节等待重传）、FIN 关闭连接等。\n在 TCP 报文段的头部中，有一个 16 位窗口字段，用于表示接收方的缓冲区可用空间大小。窗口大小值 告诉发送方当前允许发送的未确认数据量。通过该字段，发送方可以动态调整发送速度，确保不会导致接收方的缓冲区溢出。如果接收方缓冲区剩余空间减少，它会将窗口大小缩小；如果可用空间增大，它会增大窗口大小。\n应用层 # 为应用程序提供网络服务接口，用户可以直接使用这些协议访问网络资源。\nHTTP/HTTPS（Hypertext Transfer Protocol）：用于传输网页数据，HTTPS 在 HTTP 基础上添加了加密（TLS/SSL）。\nFTP（File Transfer Protocol）：用于文件传输，支持上传和下载功能。\nSMTP（Simple Mail Transfer Protocol）：用于电子邮件发送。\nPOP3（Post Office Protocol 3） 和 IMAP（Internet Message Access Protocol）：用于电子邮件接收，IMAP 支持邮件同步。\nDNS（Domain Name System）：将域名解析为 IP 地址。\nTelnet 和 SSH：用于远程登录，SSH 提供了加密的传输。\nDHCP（Dynamic Host Configuration Protocol）：用于自动分配 IP 地址。\nURL（uniform resource identifier，统一资源定位符） # 在 HTTP 协议中，用来标识唯一的资源。\nWeb 上可用的每种资源如 HTML 文档、图像、视频片段、程序等都是一个来 URI 来定位的\nURL 组成 # 访问资源的命名机制 存放资源的主机名 资源自身的名称，由路径表示，着重强调于资源。 HTTP Request # GET /562f25980001b1b106000338.jpg HTTP/1.1 Host img.mukewang.com User-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36 Accept image/webp,image/*,*/*;q=0.8 Referer http://www.imooc.com/ Accept-Encoding gzip, deflate, sdch Accept-Language zh-CN,zh;q=0.8 POST / HTTP1.1 Host:www.wrox.com User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022) Content-Type:application/x-www-form-urlencoded Content-Length:40 Connection: Keep-Alive name=Professional%20Ajax\u0026amp;publisher=Wiley HTTP Response # GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 关于 HTTP 协议，详情可参考这篇博客\nSSL\u0026amp;SSH # SSH 和 SSL(都是网络安全协议，通过加密和认证提升两台设备间传输数据的安全性。但 SSH 和 SSL 的生效方式和服务目标存在差异。\nSSH 在两台设备间创建安全隧道，使这两台设备间可以安全地发送命令、传输数据等。例如，客户端通过 SSH 远程登录到一台服务器上，就可以安全地远程管理这台服务器，在服务器上执行想要的命令。\nSSL 则是使用SSL 证书保证两台设备间安全地传输数据，而不是像 SSH 那样可以执行命令。例如，用户通过浏览器访问某安装了 SSL 证书且启用了 HTTPS 的服务器，浏览器和服务器之间可以安全地传输数据。\nSSH 就像一辆汽车，我们看不到这辆封闭的汽车里装载的是什么。而 SSL 就像一个封闭的集装箱，我们可以用不同的交通工具运输它，但看不到集装箱里装的是什么。\n","date":"27 October 2024","externalUrl":null,"permalink":"/posts/%E4%BA%94%E5%B1%82%E7%BB%93%E6%9E%84%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/","section":"Posts","summary":"\u003ch1 class=\"relative group\"\u003e🛜 五层体系结构协议复习 \n    \u003cdiv id=\"-五层体系结构协议复习\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#-%e4%ba%94%e5%b1%82%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84%e5%8d%8f%e8%ae%ae%e5%a4%8d%e4%b9%a0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003e首先我们需要了解为什么计算机网络要学习\u003cstrong\u003e五层结构模型（TCP/IP 模型）\u003c/strong\u003e，因为这更简化，便于我们了解实际网络协议，并且更贴近现实的网络组成。\u003c/p\u003e\n\u003cp\u003e而七层模型（OSI）则是由\u003cstrong\u003e国际标准化组织 ISO\u003c/strong\u003e制定的，为网络设计提供了框架，这其实是一个概念模型，虽然在实际上不常用，但为网络设计提供了参考。\u003c/p\u003e\n\n\u003ch2 class=\"relative group\"\u003e层 \n    \u003cdiv id=\"层\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e5%b1%82\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e让我们来看一下五层和七层有哪些层次，七层实际上在五层基础上加了两层：\u003c/p\u003e","title":"🛜五层体系结构协议复习","type":"posts"},{"content":"","date":"26 October 2024","externalUrl":null,"permalink":"/categories/os/","section":"Categories","summary":"","title":"OS","type":"categories"},{"content":" 处理机调度与死锁 🔒 # Q:如果系统只有一个 cpu,有两个进程要运行.进程 A 的运行时间将是 1 小时,进程 B 的运行时间是 1 分钟.那么认为操作系统让哪个进程先运行比较合理?\nA：与操作系统的调度策略有关，即更重视优先级还是到来顺序、时长等因素。\n调度 # 对处理机（CPU）资源进行分配。\n调度层次 # 高级（作业）调度、中级（内存）调度、低级（进程）调度。\n区分主要是运行频率，低级调度最频繁，也是重点。\n后备队列（Spooling Queue 或 Backup Queue）是指操作系统或系统调度过程中用于存放尚未进入内存执行的进程或任务的队列。根据实际情况，后备队列可以位于外存或与外存相关的区域，而非内存。\n作业（Job）：一组需要完成的任务或程序的组合。\n高级调度：决定哪些后备队列中的（外存中的）作业调入内存并创建进程与分配资源。 中级调度：决定哪些进程可参与竞争 CPU。（内存-\u0026gt;外存） 低级调度：决定哪个进程可以获得 CPU。 低级调度有两种方式：\n非抢占式：一直执行完成或自动阻塞。 抢占式：允许其他进程依据一定规则抢占 CPU。 （1）时间片原则、（2）优先权原则 、（3）短作业（进程）优先原则\n1. 周转时间 (Turnaround Time) # 作业（进程）从提交（进入时刻）到完成的时间称为该作业的周转时间 \\(T_i\\)：\n$$ T_i = \\text{完成时刻} - \\text{进入时刻} $$ 2. 平均周转时间 (Average Turnaround Time) # 平均周转时间为 \\(n\\) 个作业（进程）周转时间的平均值：\n$$ T = \\frac{1}{n} \\left( \\sum_{i=1}^{n} T_i \\right) $$ 3. 带权周转时间 (Weighted Turnaround Time) # 作业（进程）周转时间 \\(T*i\\) 与实际运行时间 \\(T*{si}\\) 之比称为该作业的带权周转时间 \\(W_i\\)：\n$$ W_i = \\frac{T_i}{T_{si}} $$ 4. 平均带权周转时间 (Average Weighted Turnaround Time) # 平均带权周转时间为 \\(n\\) 个作业（进程）带权周转时间的平均值：\n$$ W = \\frac{1}{n} \\left( \\sum_{i=1}^{n} \\frac{T_i}{T_{si}} \\right) $$ 调度算法 # 根据系统的资源分配策略所规定的资源分配方法\n先来先服务（FCFS） # ​ 作业调度：从后背队列选择一个或多个最先进入队列的作业\n短作业（进程）优先（SF） # 从就绪队列中选择 CPU 执行时间最短的作业\n高响应比优先（HRN） # ​ 选择待调度的作业中响应比最高的\n$$ R_p = \\frac{W_i + S_i}{S_i} $$​ Rp:响应比\n​ Wi：已等待时间\n​ Si：要求服务时间\n最高优先权（HPF） # ​ 选择优先权最高的，其中又分为：\n​ 静态优先权\n​ 动态优先权\n时间片轮转（RR） # ​ 每次为一个进程执行一个时间片 T\n多级队列调度 # ​ 将就绪队列分为多种不同队列，不同队列使用不同调度算法\n​ 多级反馈队列调度算法 # ​ 设置多个就绪队列，从高到低赋予不同优先级，每个队列采用 RR 算法，时间片长度依次增加。\n死锁 # 概述 # 死锁是指多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前进。\n产生原因 # 资源竞争 当两个或以上进程需要两个或以上资源(非剥夺性资源 or 临时性资源)：\n可剥夺性资源 非剥夺性资源 临时性资源：由某进程产生，由另一进程使用的资源。（信号量） 进程推进非法\n请求和释放资源的顺序不当。\n产生死锁必要条件 # 互斥条件：请求的资源为临界资源\n临界资源（Critical Resource）：指多个进程或线程在同一时间只能由一个进程使用的资源。对这种资源的访问必须受到严格的控制，以防止数据不一致或竞争问题的发生。典型的临界资源包括共享内存、文件、数据库等。\n可见，访问临界资源必须要有同步或互斥机制（同步：信号量，互斥：锁）！！\n请求和保持条件：申请新资源，保持旧资源\n不剥夺条件：已获得的资源，在使用完之前，不被外力剥夺。\n环路等待条件：互相等待资源\n处理死锁的基本方法 # 预防死锁：设置限制条件，破坏死锁产生 避免死锁：资源分配的动态方法 检测死锁：采取措施，解除死锁 解除死锁：剥夺资源或撤销进程回收 ♻️ 资源 银行家算法 🏦 # 安全序列 # 安全状态，是指系统能按某种进程顺序(P1, P2, …，Pn)(称〈P1, P2, …, Pn〉序列为安全序列)，来为每个进程 Pi 分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。\n​ • 可用资源：目前系统中剩余的可用资源数量。\n​ • 最大需求：每个进程所需的最大资源量。\n​ • 已分配资源：每个进程当前占用的资源量。\n需求 = 最大需求 - 已分配资源\n要找到一个安全序列，需要按照银行家算法，依次寻找一个可以满足当前可用资源条件的进程，完成该进程后，释放其资源，增加可用资源。重复这个过程，直到所有进程都完成。\n算法实现 # 核心：根据系统是否处于安全状态，来决定分配资源与否。\n对于银行家算法的具体实现主要由以下几个数据结构：\n1、可利用资源向量 Available：\n一个含有 m 个元素的数组，其中的每一个元素代表一类可利用的资源数目\n2、最大需求矩阵 Max：\n一个 n×m 的矩阵，它定义了系统中 n 个进程中的每一个进程对 m 类资源的最大需求\n3、分配矩阵 Allocation：\n一个 n×m 的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数\n4、需求矩阵 Need：\n一个 n×m 的矩阵，用以表示每一个进程还需的各类资源数\nNeed［i,j］=Max［i,j］-Allocation［i,j］\n设 Requesti 是进程 Pi 的请求向量，如果 Requesti［j］=K，表示进程 Pi 需要 K 个 Rj 类型的资源。当 Pi 发出资源请求后，系统按下述步骤进行检查：\n(1) 如果 Requesti［j］≤Need［i,j］，便转向步骤 2；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。\n(2) 如果 Requesti［j］≤Available［j］，便转向步骤(3)；否则， 表示尚无足够资源，Pi 须等待。\n(3) 系统试探着把资源分配给进程 Pi，并修改下面数据结构中的数值：\n① Available［j］∶=Available［j］-Requesti［j］;\n② Allocation［i,j］∶=Allocation［i,j］+Requesti［j］;\n③ Need［i,j］∶=Need［i,j］-Requesti［j］;\n(4) 系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程 Pi，以完成本次分配；否则， 将本次的试探分配作废，恢复原来的资源分配状态，让进程 Pi 等待。 对于系统整体安全状态的检查，引入安全性算法，核心实现如下：\n(1) 设置两个向量：① 工作向量 Work: 它表示系统可提供给进程继续运行所需的各类资源数目，它含有 m 个元素，在执行安全算法开始时，Work∶=Available; ② Finish: 它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做 Finish［i］∶=false; 当有足够资源分配给进程时， 再令 Finish［i］∶=true。 (2) 从进程集合中找到一个能满足下述条件的进程：  ① Finish［i］=false; ② Need［i,j］≤Work［j］； 若找到， 执行步骤(3)， 否则，执行步骤(4)。\n(3) 当进程 Pi 获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行： Work［j］∶=Work［i］+Allocation［i,j］; Finish［i］∶=true; go to step 2; (4) 如果所有进程的 Finish［i］=true 都满足， 则表示系统处于安全状态；否则，系统处于不安全状态。\n银行家算法的缺点如下：\n1.很少有进程能够在运行前就知道其所需资源的最大值\n2.而且进程数也不是固定的，往往在不断地变化（如新用户登录或退出）\n3.原本可用的资源也可能突然间变成不可用（如磁带机可能坏掉）\n4.银行家算法的开销较大，实时性不是很好\n解除死锁 # 利用死锁定理\n对于死锁的解除，即**（1）剥夺资源，(2) 撤消进程**。\n实用而又简便的方法是： 逐个撤消那些代价最小的进程，或者，使撤消进程的数量最少，直至获得为解除死锁所需要的足够可用的资源。\n","date":"26 October 2024","externalUrl":null,"permalink":"/posts/chapter-3-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/","section":"Posts","summary":"\u003ch1 class=\"relative group\"\u003e处理机调度与死锁 🔒 \n    \u003cdiv id=\"处理机调度与死锁-\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e5%a4%84%e7%90%86%e6%9c%ba%e8%b0%83%e5%ba%a6%e4%b8%8e%e6%ad%bb%e9%94%81-\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eQ:如果系统只有一个 cpu,有两个进程要运行.进程 A 的运行时间将是 1 小时,进程 B 的运行时间是 1 分钟.那么认为操作系统让哪个进程先运行比较合理?\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eA：与操作系统的调度策略有关，即更重视优先级还是到来顺序、时长等因素。\u003c/p\u003e\n\n\u003ch2 class=\"relative group\"\u003e调度 \n    \u003cdiv id=\"调度\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e8%b0%83%e5%ba%a6\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e对处理机（CPU）资源进行分配。\u003c/p\u003e","title":"OS：处理机调度与死锁🔒","type":"posts"},{"content":"","date":"26 October 2024","externalUrl":null,"permalink":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"操作系统","type":"tags"},{"content":"","date":"26 October 2024","externalUrl":null,"permalink":"/tags/%E6%AD%BB%E9%94%81/","section":"Tags","summary":"","title":"死锁","type":"tags"},{"content":"","date":"22 October 2024","externalUrl":null,"permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"22 October 2024","externalUrl":null,"permalink":"/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/","section":"Categories","summary":"","title":"图形学","type":"categories"},{"content":"","date":"22 October 2024","externalUrl":null,"permalink":"/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/","section":"Tags","summary":"","title":"图形学","type":"tags"},{"content":" DIP-JPEG 图像压缩 # 为什么 JPEFG 有用 # 人类眼镜的细胞对图像的感知程度，亮度比色度感知强烈的多。\n因此减少人类眼镜感知较弱的区域，即减少颜色的差异，就可以实现压缩。\n压缩步骤 # 首先需要进行色彩空间转换，每一个像素都有 RGB 的红绿蓝叠加，算法需要通过一个固定的公式算出Y（亮度）、Cb（蓝色色度）、Cr（红色色度）。\n进行色度缩减取样，很多数据会被删除。将蓝色和红色色度分量层的像素按照 2x2 像素成一个区块这样划分。然后计算每个区块的平均值，然后缩小图像（4:2:0），使得含有 1 个平均值的由 4 个像素组成的区块只占一个像素的空间。于是那些我们 👀 眼睛不易感知的红蓝色度信息量 shrink to 1/4 size，而亮度（luminance）保持不变。（网上流行的包浆图就是这么来的）\n考虑一下刚才的两步，计算之前 SIZE=1+1+1=3.0，计算之后为 SIZE=1+1/4+1/4=1.5，图像已经变为原来大小的一半了。\n当我们查看图像时，会放大图像到原始尺寸，根据 YCbCr 重新计算 RGB*（可能发生变化）*\n接下来的两个步骤是重点，进行离散余弦变换（Discrete Cosine Transform,DCT ）和量化（Quantiaztion）。这利用了人眼不擅长感知高频率的图像信息的原理，即对于细节并不能精确感知。如阴影变化，和摄影中失焦的场景。以上两个步骤会遍历图像各个部分，并找到由高频率色度或亮度的像素频繁出现的区域，然后将这些人眼很难感知的像素删除。对于三个图层中的每一个图层进行以下步骤*（以亮度涂层举例）*： - 将整个图像按照 8x8 像素划分成许多区域，称为“区块”。每个区块因此有 64 像素，每个像素用 0 ～ 255 的数值表示。如果是亮度图层就是代表亮度值。 - 减去 128 来改变各个亮度数值，这样取值范围就变成了-128 ～-127。（亮度图-128 为黑色，127 为白色） - 每一个区块内，我们可以先找到 64 个 8x8 基本图像（正弦函数的频率域图）并且每个图像都会有一个计算得出的 DCT 系数，原始图像可以通过计算出的每个基本图像 ✖️ 它对应的系数后再叠加 64 次得出。（具体的数学公式笔者也不了解，请自行网上查阅）\nDCT 不能压缩或缩小图像，但下一个步骤，量化可以\nDCT 后我们会有一个常数表，我们要把其中的各个值除上对应量化表中的各个值，并四舍五入取整。\n​ 量化表右下角数值偏高，是人眼不擅长感知德高频数据。而数值 较小的左上角是人眼更容易区分的样式所在。\n​ 在刚才的步骤中，我们舍弃了人眼无法感知的数据，针对色度， 我们会采用一个数值更大的量化表，舍去更多的颜色数据。\n小结 # 从本质上讲，整个余弦变换+量化的过程，一整张图像都使用了一组相同的 64 个基础图像和两个量化表：一个用于亮度，另一个用于色度。以便将 8x8 的像素区块转换为几个数字和一大堆的 0。 编码 # 游程编码 # 在这一步骤中，我们列出所有区块中的亮度与色度数值（更改后）。然而是这样的顺序：\n因为这样子更可能找到一连串的非 0 数字。\n接下来，在我们列出的数字中，使用游程编码 Run length encoding algorithm，列出我们有几个 0。这样只有几十个数字的列表显然比 0 ～ 255 的方法压缩的多。\n哈夫曼编码 Huffman Encoding # ​ 这种独立编码也运用在 H.264 视频压缩算法中（也被称为高级视频编码，AVC），是目前 Youtube 上传视频推荐的视频压缩算法。它使用了色度所见取样或色度抽样技术，以及离散余弦变换和量化技术的一些变种。\n​ 这里对哈夫曼编码进行简述，感兴趣的可以查阅资料自行了解。\n需要对待编码的数据中每个符号出现的频率进行统计。这些频率将用于构建哈夫曼树。\n哈夫曼树是一种二叉树，其中每个叶子节点代表一个符号，且路径长度与符号的频率相关。构建哈夫曼树的步骤如下：\n​ 1. 初始化：将所有符号视为独立的节点，并按照频率从小到大排序。\n​ 2. 合并最小频率的两个节点：将频率最小的两个节点合并为一个新的父节点，其频率为两个子节点频率之和。\n​ 3. 重复合并：将新节点加入节点列表中，重新排序，重复步骤 2，直到所有节点合并成一棵树。\n根据哈夫曼树生成哈夫曼表，从根节点到每个叶子节点的路径决定了该符号的哈夫曼编码。通常，向左分支记为 0，向右分支记为 1。\ngraph TD Root[100] Root --\u0026gt; A[45] Root --\u0026gt; CBFED[55] CBFED --\u0026gt; CB[25] CBFED --\u0026gt; FED[30] CB --\u0026gt; C[12] CB --\u0026gt; B[13] FED --\u0026gt; FE[14] FED --\u0026gt; D[16] FE --\u0026gt; F[5] FE --\u0026gt; E[9] classDiagram class HuffmanTable { +Symbol : A +Code : 0 +Symbol : B +Code : 101 +Symbol : C +Code : 100 +Symbol : D +Code : 111 +Symbol : E +Code : 1101 +Symbol : F +Code : 1100 } H.264 # ​ 然而，H.264 显然更加复杂，因为它不是像 JPEG 那样压缩单一的静态图像。每 30 帧使用 iFrame（JPEG），而其他 29 帧使用预测或双向预测,只对差异和运动进行编码，同时使用先前解码的帧作为参考。\n重构图片过程 # 让我们回到 JPEG，首先我们执行哈夫曼解码,根据哈夫曼表将编码变回 DCT 系数，例如：\nCompressed Data: 110100010... Decoded DCT Coefficients: [16, 11, -10, ...] 并且分解游程编码（disassemble），然后把一连串的数字按照去交错（De-Zigzag）的方式重新排列为 8x8 矩阵。\n接下来，我们执行反量化，通俗来讲就是讲各个值乘以量化表（之前讲过的那两张表，之前是除法），然后将所得常数乘以相应的基础图像（基础图像也是一开始就有的，之前也是除法），并将所有结果图像叠加在一起。\n将蓝色跟红色色度图像放大，并将亮度和色度值重新转换为 RGB 色彩空间。\n智能手机相机的拍摄照片至少有十几万像素，JPEG 在几秒钟内就要完成压缩和解压缩，真是不可思议！\nJPEG 的缺点 # 有时候，你可以选择压缩的程度，而这会改变量化表的数值，这种四舍五入做除法的算法，如果压缩量变大，那么就会有更多的 0，图像也会因此变得更小。\n然而，如果压缩量过大，图像会出现 artifacts，或者说块效应。它们看起开就像方块边缘的模糊斑点（类似于基础图像，就是离散余弦变换表中的特征，图像有很明显的横线或竖线）。\n其次，压缩会去除高频数据，使得图像的精确度降低。\n然而，这也是一种优点，因为没有一个相机能够做到完美对焦，所以很难分辨出未压缩和压缩的图像之间的区别。\n但是，压缩矢量图的表现不佳，直线的压缩会出现锯齿。因为 JPEG 依靠基础图像来重建直线。\n总结 # JPEG 仍是使用量最多的图片压缩算法，因为它古老、为人熟知、无版权。\n但还有很多其他图像格式，也具有很好的压缩能力。\n","date":"22 October 2024","externalUrl":null,"permalink":"/posts/%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95jpeg/","section":"Posts","summary":"\u003ch1 class=\"relative group\"\u003eDIP-JPEG 图像压缩 \n    \u003cdiv id=\"dip-jpeg-图像压缩\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#dip-jpeg-%e5%9b%be%e5%83%8f%e5%8e%8b%e7%bc%a9\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\n\u003ch2 class=\"relative group\"\u003e为什么 JPEFG 有用 \n    \u003cdiv id=\"为什么-jpefg-有用\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e4%b8%ba%e4%bb%80%e4%b9%88-jpefg-%e6%9c%89%e7%94%a8\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e人类眼镜的细胞对图像的感知程度，亮度比色度感知强烈的多。\u003c/p\u003e","title":"最常见的图像压缩算法：JPEG","type":"posts"},{"content":" Three.Js 介绍 # Three.js 由 Ricardo Cabello 在 2010 四月于 GitHub 首次发布。\nThree.js 是一个跨浏览器的使用 JavaScript 函数库或 API 来在网页浏览器中创建和展示三维计算机图形的开源通用 3D 代码库。Three.js 使用 WebGL 渲染图形，也可通过插件使用 WebGPU（实验性）、SVG 和 CSS3D 渲染器。源代码托管在 GitHub。\nInstallation # 每个 three.js 项目至少需要一个 HTML 文件来定义网页，以及一个 JavaScript 文件来运行你的 three.js 代码。下面的结构和命名选择并非必需，但为了保持一致性，本指南将在全文中使用。\nindex.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;My first three.js app\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { margin: 0; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; main.js\nimport * as THREE from \u0026#39;three\u0026#39;; ... public/\npublic/ 文件夹有时也被称为 \u0026ldquo;静态（static）\u0026ldquo;文件夹，因为其中包含的文件会原封不动地推送到网站上。纹理（textures）、音频和 3D 模型通常会放在这里。 Creating a Scene # import * as THREE from \u0026#34;three\u0026#34;; const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 ); const renderer = new THREE.WebGLRenderer(); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement); const geometry = new THREE.BoxGeometry(1, 1, 1); const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); const cube = new THREE.Mesh(geometry, material); scene.add(cube); camera.position.z = 5; function animate() { requestAnimationFrame(animate); cube.rotation.x += 0.01; cube.rotation.y += 0.02; renderer.render(scene, camera); } animate(); 以上这行代码创建了一个不断旋转的正方体。 解释代码 # 我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。\nthree.js 里有几种不同的相机，在这里，我们使用的是 PerspectiveCamera（透视摄像机）。\n第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的单位是角度(与弧度区分开)。\n第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。\n接下来的两个参数是近截面（near）和远截面（far）。 当物体某些部分比摄像机的远截面远或者比近截面近的时候，该这些部分将不会被渲染到场景中。或许现在你不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。\n接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的 WebGLRenderer 渲染器之外，Three.js 同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持 WebGL 时，可以使用这几种渲染器进行降级。\n除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用 setSize 传入一个较小的值，例如 window.innerWidth/2 和 window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。\n如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用 setSize 时，将 updateStyle（第三个参数）设为 false。例如，假设你的 canvas 标签现在已经具有了 100% 的宽和高，调用 setSize(window.innerWidth/2, window.innerHeight/2, false) 将使得你的应用程序以四分之一的大小来进行渲染。\n最后一步很重要，我们将 renderer（渲染器）的 dom 元素（renderer.domElement）添加到我们的 HTML 文档中。这就是渲染器用来显示场景给我们看的 canvas 元素。\n要创建一个立方体，我们需要一个 BoxGeometry（立方体）对象. 这个对象包含了一个立方体中所有的顶点（vertices）和面（faces）。未来我们将在这方面进行更多的探索。\n接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js 自带了几种材质，在这里我们使用的是 MeshBasicMaterial。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个 color 属性，值为 0x00ff00，也就是绿色。这里所做的事情，和在 CSS 或者 Photoshop 中使用十六进制（hex colors）颜色格式来设置颜色的方式一致。\n第三步，我们需要一个 Mesh（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。\n默认情况下，当我们调用 scene.add() 的时候，物体将会被添加到 (0,0,0) 坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n渲染场景 # 现在，如果将之前写好的代码复制到 HTML 文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用一个被叫做“渲染循环”（render loop）或者“动画循环”（animate loop）的东西。\nfunction animate() { requestAnimationFrame( animate ); renderer.render( scene, camera ); } animate(); 在这里我们创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是 60 次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说*“为什么我们不直接用 setInterval 来实现刷新的功能呢？”*当然啦，我们的确可以用 setInterval，但是，requestAnimationFrame 有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，也不会损耗电池的使用寿命。\n使立方体动起来 # 在开始之前，如果你已经将上面的代码写入到了你所创建的文件中，你可以看到一个绿色的方块。让我们来做一些更加有趣的事 —— 让它旋转起来。\n将下列代码添加到 animate() 函数中 renderer.render 调用的上方：\ncube.rotation.x += 0.01; cube.rotation.y += 0.01; 这段代码每帧都会执行（正常情况下是 60 次/秒），这就让立方体有了一个看起来很不错的旋转动画。基本上来说，当应用程序运行时，如果你想要移动或者改变任何场景中的东西，都必须要经过这个动画循环。当然，你可以在这个动画循环里调用别的函数，这样你就不会写出有上百行代码的 animate 函数。\n结果 # 祝贺你！你现在已经成功完成了你的第一个 three.js 应用程序。虽然它很简单，但现在你已经有了一个入门的起点。\n","date":"21 October 2024","externalUrl":null,"permalink":"/posts/three-js%E7%AE%80%E4%BB%8B/","section":"Posts","summary":"\u003ch1 class=\"relative group\"\u003eThree.Js 介绍 \n    \u003cdiv id=\"threejs-介绍\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#threejs-%e4%bb%8b%e7%bb%8d\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eThree.js 由 Ricardo Cabello 在 2010 四月于 GitHub 首次发布。\u003c/p\u003e\n\u003cp\u003eThree.js 是一个跨浏览器的使用 JavaScript 函数库或 API 来在网页浏览器中创建和展示三维计算机图形的开源通用 3D 代码库。Three.js 使用 WebGL 渲染图形，也可通过插件使用 WebGPU（实验性）、SVG 和 CSS3D 渲染器。源代码托管在 GitHub。\u003c/p\u003e","title":"Three.js简介","type":"posts"},{"content":"","date":"21 October 2024","externalUrl":null,"permalink":"/tags/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/","section":"Tags","summary":"","title":"渲染引擎","type":"tags"},{"content":" axios # axios 对原生 ajax 进行了封装，简化书写，快速开发，用于发送异步请求。\n查看 axios docs\n定义 # Axios 是一个基于 promise 网络请求库，作用于node.js 和浏览器中。 它是 isomorphic 的(即同一套代码可以运行在浏览器和 node.js 中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。\n用例 # 发起一个 GET 请求\nconst axios = require(\u0026#34;axios\u0026#34;); // 向给定ID的用户发起请求 axios .get(\u0026#34;/user?ID=12345\u0026#34;) .then(function (response) { // 处理成功情况 console.log(response); }) .catch(function (error) { // 处理错误情况 console.log(error); }) .finally(function () { // 总是会执行 }); // 上述请求也可以按以下方式完成（可选） axios .get(\u0026#34;/user\u0026#34;, { params: { ID: 12345, }, }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }) .finally(function () { // 总是会执行 }); // 支持async/await用法 async function getUser() { try { const response = await axios.get(\u0026#34;/user?ID=12345\u0026#34;); console.log(response); } catch (error) { console.error(error); } } 注意: 由于async/await 是 ECMAScript 2017 中的一部分，而且在 IE 和一些旧的浏览器中不支持，所以使用时务必要小心。\n发起一个 POST 请求\naxios .post(\u0026#34;/user\u0026#34;, { firstName: \u0026#34;Fred\u0026#34;, lastName: \u0026#34;Flintstone\u0026#34;, }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); ","date":"21 October 2024","externalUrl":null,"permalink":"/posts/axios%E7%AE%80%E4%BB%8B/","section":"Posts","summary":"\u003ch1 class=\"relative group\"\u003eaxios \n    \u003cdiv id=\"axios\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#axios\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003e\n\n\n\n\n\n\n\u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" alt=\"axios\" src=\"/images/axios.png\"\u003e\n\n  \n\u003c/figure\u003e\n\u003c/p\u003e\n\u003cp\u003eaxios 对原生 ajax 进行了封装，简化书写，快速开发，用于发送\u003cstrong\u003e异步\u003c/strong\u003e请求。\u003c/p\u003e\n\u003cp\u003e\u003ca\n  href=\"https://axios-http.com/zh/docs/intro\"\n    target=\"_blank\"\n  \u003e查看 axios docs\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 class=\"relative group\"\u003e定义 \n    \u003cdiv id=\"定义\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e5%ae%9a%e4%b9%89\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003eAxios 是一个基于 \u003cem\u003e\u003ca\n  href=\"https://javascript.info/promise-basics\"\n    target=\"_blank\"\n  \u003epromise\u003c/a\u003e\u003c/em\u003e 网络请求库，作用于\u003ca\n  href=\"https://nodejs.org/\"\n    target=\"_blank\"\n  \u003e\u003ccode\u003enode.js\u003c/code\u003e\u003c/a\u003e 和浏览器中。 它是 \u003cem\u003e\u003ca\n  href=\"https://www.lullabot.com/articles/what-is-an-isomorphic-application\"\n    target=\"_blank\"\n  \u003eisomorphic\u003c/a\u003e\u003c/em\u003e 的(即同一套代码可以运行在浏览器和 node.js 中)。在服务端它使用原生 node.js \u003ccode\u003ehttp\u003c/code\u003e 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。\u003c/p\u003e","title":"axios简介","type":"posts"},{"content":"","date":"21 October 2024","externalUrl":null,"permalink":"/tags/javascript/","section":"Tags","summary":"","title":"Javascript","type":"tags"},{"content":"","date":"21 October 2024","externalUrl":null,"permalink":"/tags/%E5%BC%82%E6%AD%A5/","section":"Tags","summary":"","title":"异步","type":"tags"},{"content":"","date":"21 October 2024","externalUrl":null,"permalink":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/","section":"Categories","summary":"","title":"计算机科学","type":"categories"},{"content":"","date":"21 October 2024","externalUrl":null,"permalink":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/","section":"Tags","summary":"","title":"计算机科学","type":"tags"},{"content":" Computer Science Map # 计算机科学基础理论（Theroy） # 1. 计算性理论 computability theroy # 2. 算法 algorithm # 3. 信息论 information theroy # 4. 密码学 cryptography # 5. 其他（逻辑、图论、计算几何、自动机理论、量子计算、并行编程、形式化方法、数据结构） # 计算机工程（engineering） # 1. 处理机调度 # 2. 计算机体系结构 architecure # 3. 软件与编程语言 # 4. 编译器 compilers # 5. 操作系统 operating systems # 6. 软件工程 software engineering # 7. 网络 networking # 8. 数据管理 data management # 9. 性能 performance # 10. 图形学 graphics # 应用（Applications） # 1. 优化 optimization # 2. 布尔可满足性问题 boolean satisfiability（SAT） # 3. 人工智能 artificial intelligence # 4. 机器学习 machine learning # 计算机视觉 computer vision 图像处理技术 image processing techniques 自然语言处理 natural language processing 5. 大数据 big data # 6. 物联网 Internet of things # 7. hacking # 8. 计算科学 computational science # 9. 超算 supter computing # 10. 人机交互 human computer interacting # 11。 机器人学 robitics # ","date":"21 October 2024","externalUrl":null,"permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%86%E6%94%AF/","section":"Posts","summary":"\u003ch1 class=\"relative group\"\u003eComputer Science Map \n    \u003cdiv id=\"computer-science-map\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#computer-science-map\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\n\u003ch2 class=\"relative group\"\u003e计算机科学基础理论（Theroy） \n    \u003cdiv id=\"计算机科学基础理论theroy\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6%e5%9f%ba%e7%a1%80%e7%90%86%e8%ae%batheroy\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\n\u003ch5 class=\"relative group\"\u003e1. 计算性理论 computability theroy \n    \u003cdiv id=\"1-计算性理论-computability-theroy\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#1-%e8%ae%a1%e7%ae%97%e6%80%a7%e7%90%86%e8%ae%ba-computability-theroy\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e2. 算法 algorithm \n    \u003cdiv id=\"2-算法-algorithm\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#2-%e7%ae%97%e6%b3%95-algorithm\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e3. 信息论 information theroy \n    \u003cdiv id=\"3-信息论-information-theroy\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#3-%e4%bf%a1%e6%81%af%e8%ae%ba-information-theroy\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e4. 密码学 cryptography \n    \u003cdiv id=\"4-密码学-cryptography\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#4-%e5%af%86%e7%a0%81%e5%ad%a6-cryptography\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e5. 其他（逻辑、图论、计算几何、自动机理论、量子计算、并行编程、形式化方法、数据结构） \n    \u003cdiv id=\"5-其他逻辑图论计算几何自动机理论量子计算并行编程形式化方法数据结构\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#5-%e5%85%b6%e4%bb%96%e9%80%bb%e8%be%91%e5%9b%be%e8%ae%ba%e8%ae%a1%e7%ae%97%e5%87%a0%e4%bd%95%e8%87%aa%e5%8a%a8%e6%9c%ba%e7%90%86%e8%ae%ba%e9%87%8f%e5%ad%90%e8%ae%a1%e7%ae%97%e5%b9%b6%e8%a1%8c%e7%bc%96%e7%a8%8b%e5%bd%a2%e5%bc%8f%e5%8c%96%e6%96%b9%e6%b3%95%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch2 class=\"relative group\"\u003e计算机工程（engineering） \n    \u003cdiv id=\"计算机工程engineering\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%b7%a5%e7%a8%8bengineering\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\n\u003ch5 class=\"relative group\"\u003e1. 处理机调度 \n    \u003cdiv id=\"1-处理机调度\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#1-%e5%a4%84%e7%90%86%e6%9c%ba%e8%b0%83%e5%ba%a6\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e2. 计算机体系结构 architecure \n    \u003cdiv id=\"2-计算机体系结构-architecure\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#2-%e8%ae%a1%e7%ae%97%e6%9c%ba%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84-architecure\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e3. 软件与编程语言 \n    \u003cdiv id=\"3-软件与编程语言\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#3-%e8%bd%af%e4%bb%b6%e4%b8%8e%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e4. 编译器 compilers \n    \u003cdiv id=\"4-编译器-compilers\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#4-%e7%bc%96%e8%af%91%e5%99%a8-compilers\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e5. 操作系统 operating systems \n    \u003cdiv id=\"5-操作系统-operating-systems\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#5-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f-operating-systems\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e6. 软件工程 software engineering \n    \u003cdiv id=\"6-软件工程-software-engineering\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#6-%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b-software-engineering\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e7. 网络 networking \n    \u003cdiv id=\"7-网络-networking\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#7-%e7%bd%91%e7%bb%9c-networking\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e8. 数据管理 data management \n    \u003cdiv id=\"8-数据管理-data-management\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#8-%e6%95%b0%e6%8d%ae%e7%ae%a1%e7%90%86-data-management\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e9. 性能 performance \n    \u003cdiv id=\"9-性能-performance\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#9-%e6%80%a7%e8%83%bd-performance\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e10. 图形学 graphics \n    \u003cdiv id=\"10-图形学-graphics\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#10-%e5%9b%be%e5%bd%a2%e5%ad%a6-graphics\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch2 class=\"relative group\"\u003e应用（Applications） \n    \u003cdiv id=\"应用applications\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e5%ba%94%e7%94%a8applications\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\n\u003ch5 class=\"relative group\"\u003e1. 优化 optimization \n    \u003cdiv id=\"1-优化-optimization\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#1-%e4%bc%98%e5%8c%96-optimization\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e2. 布尔可满足性问题 boolean satisfiability（SAT） \n    \u003cdiv id=\"2-布尔可满足性问题-boolean-satisfiabilitysat\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#2-%e5%b8%83%e5%b0%94%e5%8f%af%e6%bb%a1%e8%b6%b3%e6%80%a7%e9%97%ae%e9%a2%98-boolean-satisfiabilitysat\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e3. 人工智能 artificial intelligence \n    \u003cdiv id=\"3-人工智能-artificial-intelligence\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#3-%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd-artificial-intelligence\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e4. 机器学习 machine learning \n    \u003cdiv id=\"4-机器学习-machine-learning\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#4-%e6%9c%ba%e5%99%a8%e5%ad%a6%e4%b9%a0-machine-learning\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003e计算机视觉 computer vision\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e图像处理技术 image processing techniques\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e自然语言处理 natural language processing\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch5 class=\"relative group\"\u003e5. 大数据 big data \n    \u003cdiv id=\"5-大数据-big-data\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#5-%e5%a4%a7%e6%95%b0%e6%8d%ae-big-data\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e6. 物联网 Internet of things \n    \u003cdiv id=\"6-物联网-internet-of-things\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#6-%e7%89%a9%e8%81%94%e7%bd%91-internet-of-things\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e7. hacking \n    \u003cdiv id=\"7-hacking\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#7-hacking\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e8. 计算科学 computational science \n    \u003cdiv id=\"8-计算科学-computational-science\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#8-%e8%ae%a1%e7%ae%97%e7%a7%91%e5%ad%a6-computational-science\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e9. 超算 supter computing \n    \u003cdiv id=\"9-超算-supter-computing\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#9-%e8%b6%85%e7%ae%97-supter-computing\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e10. 人机交互 human computer interacting \n    \u003cdiv id=\"10-人机交互-human-computer-interacting\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#10-%e4%ba%ba%e6%9c%ba%e4%ba%a4%e4%ba%92-human-computer-interacting\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e\n\n\u003ch5 class=\"relative group\"\u003e11。 机器人学 robitics \n    \u003cdiv id=\"11-机器人学-robitics\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#11-%e6%9c%ba%e5%99%a8%e4%ba%ba%e5%ad%a6-robitics\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h5\u003e","title":"计算机科学分支 CS Map","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":" 关于我 # bg: 鲍宇翔，上海大学(SHU)，2022 级本科生，计算机科学与技术专业。\n关于自我经历和感想 # 可以查看我博客下自我分类下的文章。\n建站目的 # 在这个信息聚合的时代，不被搜索引擎 SEO 和平台算法束缚是难能可贵的。 ","externalUrl":null,"permalink":"/about/","section":"鲍宇翔的博客","summary":"\u003ch2 class=\"relative group\"\u003e关于我 \n    \u003cdiv id=\"关于我\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e5%85%b3%e4%ba%8e%e6%88%91\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ebg\u003c/code\u003e: \u003cem\u003e鲍宇翔\u003c/em\u003e，\u003cem\u003e上海大学(SHU)，2022 级本科生，计算机科学与技术专业。\u003c/em\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003c!-- \n\n  \u003cdiv align=\"center\"\u003e\n\u003cp\u003e\u003ca\n  href=\"https://git.io/typing-svg\"\n    target=\"_blank\"\n  \u003e\n\n\n\n\n\n\n\u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" alt=\"Typing SVG\" src=\"https://readme-typing-svg.herokuapp.com?font=Input\u0026#43;Mono\u0026amp;weight=750\u0026amp;pause=1000\u0026amp;color=8A95EDED\u0026amp;center=true\u0026amp;vCenter=true\u0026amp;random=true\u0026amp;width=435\u0026amp;lines=Hi\u0026#43;There!\u0026#43;I\u0026#43;am\u0026#43;Ethan\u0026#43;Bao;Let%27s\u0026#43;Enjoy\u0026#43;The\u0026#43;Process\u0026#43;Of\u0026#43;Coding!\"\u003e\n\n  \n\u003c/figure\u003e\n\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca\n  href=\"https://github.com/EthanBao27\"\n    target=\"_blank\"\n  \u003e\n\n\n\n\n\n\n\u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" alt=\"Profile Views\" src=\"https://komarev.com/ghpvc/?username=EthanBao27\u0026amp;color=7CAEA3\u0026amp;style=for-the-badge\"\u003e\n\n  \n\u003c/figure\u003e\n\u003c/a\u003e\u003c/p\u003e\n\u003cimg src=\"https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExNXBkenJtZDBpb3E5NzFodDNoN2piMnBpdDRzcWdkeXk0cXFtaTBzZiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/IOwzBZrp0VIpdXkYDc/giphy.gif\" width=\"260\" /\u003e\n\u003c/div\u003e\n\u003cdiv align=\"center\"\u003e\n\u003cp\u003e\u003cem\u003e\u003ch3\u003eAbout\u003c/h3\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eYou can call me \u003cem\u003eEthan Bao\u003c/em\u003e\u003c/p\u003e","title":"关于我","type":"page"}]